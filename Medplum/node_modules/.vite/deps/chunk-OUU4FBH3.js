// node_modules/@medplum/core/dist/esm/index.mjs
var Fe = class {
  constructor(e, t) {
    this.operator = e;
    this.child = t;
  }
  toString() {
    return `${this.operator}(${this.child.toString()})`;
  }
};
var H = class {
  constructor(e, t, n) {
    this.operator = e;
    this.left = t;
    this.right = n;
  }
  toString() {
    return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;
  }
};
var _e = class {
  constructor() {
    this.prefixParselets = {};
    this.infixParselets = {};
  }
  registerInfix(e, t) {
    return this.infixParselets[e] = t, this;
  }
  registerPrefix(e, t) {
    return this.prefixParselets[e] = t, this;
  }
  prefix(e, t, n) {
    return this.registerPrefix(e, { parse(i, o) {
      let s = i.consumeAndParse(t);
      return n(o, s);
    } });
  }
  infixLeft(e, t, n) {
    return this.registerInfix(e, { parse(i, o, s) {
      let a = i.consumeAndParse(t);
      return n(o, s, a);
    }, precedence: t });
  }
  construct(e) {
    return new It(e, this.prefixParselets, this.infixParselets);
  }
};
var It = class {
  constructor(e, t, n) {
    this.tokens = e, this.prefixParselets = t, this.infixParselets = n;
  }
  hasMore() {
    return this.tokens.length > 0;
  }
  match(e) {
    var _a;
    return ((_a = this.peek()) == null ? void 0 : _a.id) !== e ? false : (this.consume(), true);
  }
  consumeAndParse(e = 1 / 0) {
    let t = this.consume(), n = this.prefixParselets[t.id];
    if (!n)
      throw Error(`Parse error at "${t.value}" (line ${t.line}, column ${t.column}). No matching prefix parselet.`);
    let i = n.parse(this, t);
    for (; e > this.getPrecedence(); ) {
      let o = this.consume();
      i = this.getInfixParselet(o).parse(this, i, o);
    }
    return i;
  }
  getPrecedence() {
    let e = this.peek();
    if (!e)
      return 1 / 0;
    let t = this.getInfixParselet(e);
    return t ? t.precedence : 1 / 0;
  }
  consume(e, t) {
    var _a, _b;
    if (!this.tokens.length)
      throw Error("Cant consume unknown more tokens.");
    if (e && ((_a = this.peek()) == null ? void 0 : _a.id) !== e) {
      let n = this.peek();
      throw Error(`Expected ${e} but got "${n.id}" (${n.value}) at line ${n.line} column ${n.column}.`);
    }
    if (t && ((_b = this.peek()) == null ? void 0 : _b.value) !== t) {
      let n = this.peek();
      throw Error(`Expected "${t}" but got "${n.value}" at line ${n.line} column ${n.column}.`);
    }
    return this.tokens.shift();
  }
  peek() {
    return this.tokens.length > 0 ? this.tokens[0] : void 0;
  }
  removeComments() {
    this.tokens = this.tokens.filter((e) => e.id !== "Comment");
  }
  getInfixParselet(e) {
    return this.infixParselets[e.id === "Symbol" ? e.value : e.id];
  }
};
var Pr = "http://unitsofmeasure.org";
var Ys = "http://loinc.org";
var Zs = "http://snomed.info/sct";
var Xs = "http://www.nlm.nih.gov/research/umls/rxnorm";
var ea = "http://www.ama-assn.org/go/cpt";
var ta = "http://hl7.org/fhir/sid/icd-10";
var wr = "http://hl7.org";
var kt = "ok";
var Ue = "created";
var Ot = "gone";
var Vt = "not-modified";
var Dt = "not-found";
var Ar = "conflict";
var Ir = "unauthorized";
var kr = "precondition-failed";
var Or = "forbidden";
var Vr = "too-many-requests";
var Le = "accepted";
var na = { resourceType: "OperationOutcome", id: kt, issue: [{ severity: "information", code: "informational", details: { text: "All OK" } }] };
var ia = { resourceType: "OperationOutcome", id: Ue, issue: [{ severity: "information", code: "informational", details: { text: "Created" } }] };
var oa = { resourceType: "OperationOutcome", id: Vt, issue: [{ severity: "information", code: "informational", details: { text: "Not Modified" } }] };
var Dr = { resourceType: "OperationOutcome", id: Dt, issue: [{ severity: "error", code: "not-found", details: { text: "Not found" } }] };
var sa = { resourceType: "OperationOutcome", id: Ir, issue: [{ severity: "error", code: "login", details: { text: "Unauthorized" } }] };
var aa = { resourceType: "OperationOutcome", id: Or, issue: [{ severity: "error", code: "forbidden", details: { text: "Forbidden" } }] };
var ca = { resourceType: "OperationOutcome", id: Ot, issue: [{ severity: "error", code: "deleted", details: { text: "Gone" } }] };
var ua = { resourceType: "OperationOutcome", id: kr, issue: [{ severity: "error", code: "lock-error", details: { text: "Precondition Failed" } }] };
var la = { resourceType: "OperationOutcome", id: Vr, issue: [{ severity: "error", code: "throttled", details: { text: "Too Many Requests" } }] };
function pa(r4) {
  return { resourceType: "OperationOutcome", id: Le, issue: [{ severity: "information", code: "informational", details: { text: "Accepted" }, diagnostics: r4 }] };
}
function b(r4, e) {
  return { resourceType: "OperationOutcome", issue: [{ severity: "error", code: "invalid", details: { text: r4 }, expression: e ? [e] : void 0 }] };
}
function da(r4) {
  return { resourceType: "OperationOutcome", id: Ar, issue: [{ severity: "error", code: "conflict", details: { text: r4 } }] };
}
function m(r4) {
  return { resourceType: "OperationOutcome", issue: [{ severity: "error", code: "structure", details: { text: r4 } }] };
}
function Mr(r4) {
  return { resourceType: "OperationOutcome", issue: [{ severity: "error", code: "exception", details: { text: "Internal server error" }, diagnostics: r4.toString() }] };
}
function ce(r4) {
  return typeof r4 == "object" && r4 !== null && r4.resourceType === "OperationOutcome";
}
function Mt(r4) {
  return r4.id === kt || r4.id === Ue || r4.id === Vt || r4.id === Le;
}
function fa(r4) {
  return r4.id === Ue;
}
function ma(r4) {
  return r4.id === Le;
}
function ha(r4) {
  return r4.id === Dt;
}
function ya(r4) {
  return r4.id === Ot;
}
function ga(r4) {
  var _a, _b;
  switch (r4.id) {
    case kt:
      return 200;
    case Ue:
      return 201;
    case Le:
      return 202;
    case Vt:
      return 304;
    case Ir:
      return 401;
    case Or:
      return 403;
    case Dt:
      return 404;
    case Ar:
      return 409;
    case Ot:
      return 410;
    case kr:
      return 412;
    case Vr:
      return 429;
    default:
      return ((_b = (_a = r4.issue) == null ? void 0 : _a[0]) == null ? void 0 : _b.code) === "exception" ? 500 : 400;
  }
}
function xa(r4, e) {
  if (!Mt(r4) || e === void 0)
    throw new d(r4);
}
var d = class extends Error {
  constructor(e, t) {
    super(Nr(e)), this.outcome = e, this.cause = t;
  }
};
function Be(r4) {
  return r4 instanceof d ? r4.outcome : ce(r4) ? r4 : b(di(r4));
}
function di(r4) {
  return r4 ? typeof r4 == "string" ? r4 : r4 instanceof Error ? r4.message : ce(r4) ? Nr(r4) : typeof r4 == "object" && "code" in r4 && typeof r4.code == "string" ? r4.code : JSON.stringify(r4) : "Unknown error";
}
function Nr(r4) {
  var _a;
  let e = ((_a = r4.issue) == null ? void 0 : _a.map(fi)) ?? [];
  return e.length > 0 ? e.join("; ") : "Unknown error";
}
function fi(r4) {
  var _a, _b;
  let e;
  return ((_a = r4.details) == null ? void 0 : _a.text) ? r4.diagnostics ? e = `${r4.details.text} (${r4.diagnostics})` : e = r4.details.text : r4.diagnostics ? e = r4.diagnostics : e = "Unknown error", ((_b = r4.expression) == null ? void 0 : _b.length) && (e += ` (${r4.expression.join(", ")})`), e;
}
function ue(r4, e, t, n, i) {
  let o = { severity: r4, code: e, details: { text: t }, expression: [n] };
  return i && (o.diagnostics = JSON.stringify(i)), o;
}
function g(r4, e) {
  return ue("error", "structure", e, r4);
}
function Fr(r4, e) {
  return ue("error", "invariant", `Constraint ${e.key} not met: ${e.description}`, r4, { fhirpath: e.expression });
}
function _r(r4, e, t, n) {
  return ue("error", "processing", e, r4, { ...n, error: t });
}
var mi = { "http://hl7.org/fhirpath/System.String": "string" };
function Ta(r4) {
  var _a;
  let e = {};
  return r4.min !== 0 && (e.min = r4.min), r4.max !== 1 && Number.isFinite(r4.max) ? e.max = r4.max : r4.max === Number.POSITIVE_INFINITY && (e.max = Number.MAX_SAFE_INTEGER), e.type = (_a = r4.type) == null ? void 0 : _a.map((t) => ({ ...t, extension: void 0, code: mi[t.code] ?? t.code })), e;
}
function hi(r4, e) {
  let t = e.max && e.max === Number.MAX_SAFE_INTEGER ? Number.POSITIVE_INFINITY : e.max;
  return { path: r4, description: "", type: e.type ?? [], min: e.min ?? 0, max: t ?? 1, isArray: !!t && t > 1, constraints: [] };
}
function Ur(r4) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let [t, n] of Object.entries(r4))
    e[t] = { name: t, elements: Object.fromEntries(Object.entries(n.elements).map(([i, o]) => [i, hi(i, o)])), constraints: [], innerTypes: [] };
  return e;
}
var Lr = { Element: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] } } }, BackboneElement: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] } } }, Address: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, use: { type: [{ code: "code" }] }, type: { type: [{ code: "code" }] }, text: { type: [{ code: "string" }] }, line: { max: 9007199254740991, type: [{ code: "string" }] }, city: { type: [{ code: "string" }] }, district: { type: [{ code: "string" }] }, state: { type: [{ code: "string" }] }, postalCode: { type: [{ code: "string" }] }, country: { type: [{ code: "string" }] }, period: { type: [{ code: "Period" }] } } }, Age: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, Annotation: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, "author[x]": { type: [{ code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Practitioner", "http://hl7.org/fhir/StructureDefinition/Patient", "http://hl7.org/fhir/StructureDefinition/RelatedPerson", "http://hl7.org/fhir/StructureDefinition/Organization"] }, { code: "string" }] }, time: { type: [{ code: "dateTime" }] }, text: { min: 1, type: [{ code: "markdown" }] } } }, Attachment: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, contentType: { type: [{ code: "code" }] }, language: { type: [{ code: "code" }] }, data: { type: [{ code: "base64Binary" }] }, url: { type: [{ code: "url" }] }, size: { type: [{ code: "unsignedInt" }] }, hash: { type: [{ code: "base64Binary" }] }, title: { type: [{ code: "string" }] }, creation: { type: [{ code: "dateTime" }] } } }, CodeableConcept: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, coding: { max: 9007199254740991, type: [{ code: "Coding" }] }, text: { type: [{ code: "string" }] } } }, Coding: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, system: { type: [{ code: "uri" }] }, version: { type: [{ code: "string" }] }, code: { type: [{ code: "code" }] }, display: { type: [{ code: "string" }] }, userSelected: { type: [{ code: "boolean" }] } } }, ContactDetail: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, name: { type: [{ code: "string" }] }, telecom: { max: 9007199254740991, type: [{ code: "ContactPoint" }] } } }, ContactPoint: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, system: { type: [{ code: "code" }] }, value: { type: [{ code: "string" }] }, use: { type: [{ code: "code" }] }, rank: { type: [{ code: "positiveInt" }] }, period: { type: [{ code: "Period" }] } } }, Contributor: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, type: { min: 1, type: [{ code: "code" }] }, name: { min: 1, type: [{ code: "string" }] }, contact: { max: 9007199254740991, type: [{ code: "ContactDetail" }] } } }, Count: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, DataRequirement: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, type: { min: 1, type: [{ code: "code" }] }, profile: { max: 9007199254740991, type: [{ code: "canonical", targetProfile: ["http://hl7.org/fhir/StructureDefinition/StructureDefinition"] }] }, "subject[x]": { type: [{ code: "CodeableConcept" }, { code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Group"] }] }, mustSupport: { max: 9007199254740991, type: [{ code: "string" }] }, codeFilter: { max: 9007199254740991, type: [{ code: "DataRequirementCodeFilter" }] }, dateFilter: { max: 9007199254740991, type: [{ code: "DataRequirementDateFilter" }] }, limit: { type: [{ code: "positiveInt" }] }, sort: { max: 9007199254740991, type: [{ code: "DataRequirementSort" }] } } }, Distance: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, Dosage: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, sequence: { type: [{ code: "integer" }] }, text: { type: [{ code: "string" }] }, additionalInstruction: { max: 9007199254740991, type: [{ code: "CodeableConcept" }] }, patientInstruction: { type: [{ code: "string" }] }, timing: { type: [{ code: "Timing" }] }, "asNeeded[x]": { type: [{ code: "boolean" }, { code: "CodeableConcept" }] }, site: { type: [{ code: "CodeableConcept" }] }, route: { type: [{ code: "CodeableConcept" }] }, method: { type: [{ code: "CodeableConcept" }] }, doseAndRate: { max: 9007199254740991, type: [{ code: "DosageDoseAndRate" }] }, maxDosePerPeriod: { type: [{ code: "Ratio" }] }, maxDosePerAdministration: { type: [{ code: "Quantity", profile: ["http://hl7.org/fhir/StructureDefinition/SimpleQuantity"] }] }, maxDosePerLifetime: { type: [{ code: "Quantity", profile: ["http://hl7.org/fhir/StructureDefinition/SimpleQuantity"] }] } } }, Duration: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, ElementDefinition: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, path: { min: 1, type: [{ code: "string" }] }, representation: { max: 9007199254740991, type: [{ code: "code" }] }, sliceName: { type: [{ code: "string" }] }, sliceIsConstraining: { type: [{ code: "boolean" }] }, label: { type: [{ code: "string" }] }, code: { max: 9007199254740991, type: [{ code: "Coding" }] }, slicing: { type: [{ code: "ElementDefinitionSlicing" }] }, short: { type: [{ code: "string" }] }, definition: { type: [{ code: "markdown" }] }, comment: { type: [{ code: "markdown" }] }, requirements: { type: [{ code: "markdown" }] }, alias: { max: 9007199254740991, type: [{ code: "string" }] }, min: { type: [{ code: "unsignedInt" }] }, max: { type: [{ code: "string" }] }, base: { type: [{ code: "ElementDefinitionBase" }] }, contentReference: { type: [{ code: "uri" }] }, type: { max: 9007199254740991, type: [{ code: "ElementDefinitionType" }] }, "defaultValue[x]": { type: [{ code: "base64Binary" }, { code: "boolean" }, { code: "canonical" }, { code: "code" }, { code: "date" }, { code: "dateTime" }, { code: "decimal" }, { code: "id" }, { code: "instant" }, { code: "integer" }, { code: "markdown" }, { code: "oid" }, { code: "positiveInt" }, { code: "string" }, { code: "time" }, { code: "unsignedInt" }, { code: "uri" }, { code: "url" }, { code: "uuid" }, { code: "Address" }, { code: "Age" }, { code: "Annotation" }, { code: "Attachment" }, { code: "CodeableConcept" }, { code: "Coding" }, { code: "ContactPoint" }, { code: "Count" }, { code: "Distance" }, { code: "Duration" }, { code: "HumanName" }, { code: "Identifier" }, { code: "Money" }, { code: "Period" }, { code: "Quantity" }, { code: "Range" }, { code: "Ratio" }, { code: "Reference" }, { code: "SampledData" }, { code: "Signature" }, { code: "Timing" }, { code: "ContactDetail" }, { code: "Contributor" }, { code: "DataRequirement" }, { code: "Expression" }, { code: "ParameterDefinition" }, { code: "RelatedArtifact" }, { code: "TriggerDefinition" }, { code: "UsageContext" }, { code: "Dosage" }, { code: "Meta" }] }, meaningWhenMissing: { type: [{ code: "markdown" }] }, orderMeaning: { type: [{ code: "string" }] }, "fixed[x]": { type: [{ code: "base64Binary" }, { code: "boolean" }, { code: "canonical" }, { code: "code" }, { code: "date" }, { code: "dateTime" }, { code: "decimal" }, { code: "id" }, { code: "instant" }, { code: "integer" }, { code: "markdown" }, { code: "oid" }, { code: "positiveInt" }, { code: "string" }, { code: "time" }, { code: "unsignedInt" }, { code: "uri" }, { code: "url" }, { code: "uuid" }, { code: "Address" }, { code: "Age" }, { code: "Annotation" }, { code: "Attachment" }, { code: "CodeableConcept" }, { code: "Coding" }, { code: "ContactPoint" }, { code: "Count" }, { code: "Distance" }, { code: "Duration" }, { code: "HumanName" }, { code: "Identifier" }, { code: "Money" }, { code: "Period" }, { code: "Quantity" }, { code: "Range" }, { code: "Ratio" }, { code: "Reference" }, { code: "SampledData" }, { code: "Signature" }, { code: "Timing" }, { code: "ContactDetail" }, { code: "Contributor" }, { code: "DataRequirement" }, { code: "Expression" }, { code: "ParameterDefinition" }, { code: "RelatedArtifact" }, { code: "TriggerDefinition" }, { code: "UsageContext" }, { code: "Dosage" }, { code: "Meta" }] }, "pattern[x]": { type: [{ code: "base64Binary" }, { code: "boolean" }, { code: "canonical" }, { code: "code" }, { code: "date" }, { code: "dateTime" }, { code: "decimal" }, { code: "id" }, { code: "instant" }, { code: "integer" }, { code: "markdown" }, { code: "oid" }, { code: "positiveInt" }, { code: "string" }, { code: "time" }, { code: "unsignedInt" }, { code: "uri" }, { code: "url" }, { code: "uuid" }, { code: "Address" }, { code: "Age" }, { code: "Annotation" }, { code: "Attachment" }, { code: "CodeableConcept" }, { code: "Coding" }, { code: "ContactPoint" }, { code: "Count" }, { code: "Distance" }, { code: "Duration" }, { code: "HumanName" }, { code: "Identifier" }, { code: "Money" }, { code: "Period" }, { code: "Quantity" }, { code: "Range" }, { code: "Ratio" }, { code: "Reference" }, { code: "SampledData" }, { code: "Signature" }, { code: "Timing" }, { code: "ContactDetail" }, { code: "Contributor" }, { code: "DataRequirement" }, { code: "Expression" }, { code: "ParameterDefinition" }, { code: "RelatedArtifact" }, { code: "TriggerDefinition" }, { code: "UsageContext" }, { code: "Dosage" }, { code: "Meta" }] }, example: { max: 9007199254740991, type: [{ code: "ElementDefinitionExample" }] }, "minValue[x]": { type: [{ code: "date" }, { code: "dateTime" }, { code: "instant" }, { code: "time" }, { code: "decimal" }, { code: "integer" }, { code: "positiveInt" }, { code: "unsignedInt" }, { code: "Quantity" }] }, "maxValue[x]": { type: [{ code: "date" }, { code: "dateTime" }, { code: "instant" }, { code: "time" }, { code: "decimal" }, { code: "integer" }, { code: "positiveInt" }, { code: "unsignedInt" }, { code: "Quantity" }] }, maxLength: { type: [{ code: "integer" }] }, condition: { max: 9007199254740991, type: [{ code: "id" }] }, constraint: { max: 9007199254740991, type: [{ code: "ElementDefinitionConstraint" }] }, mustSupport: { type: [{ code: "boolean" }] }, isModifier: { type: [{ code: "boolean" }] }, isModifierReason: { type: [{ code: "string" }] }, isSummary: { type: [{ code: "boolean" }] }, binding: { type: [{ code: "ElementDefinitionBinding" }] }, mapping: { max: 9007199254740991, type: [{ code: "ElementDefinitionMapping" }] } } }, Expression: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, description: { type: [{ code: "string" }] }, name: { type: [{ code: "id" }] }, language: { min: 1, type: [{ code: "code" }] }, expression: { type: [{ code: "string" }] }, reference: { type: [{ code: "uri" }] } } }, Extension: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, url: { min: 1, type: [{ code: "uri" }] }, "value[x]": { type: [{ code: "base64Binary" }, { code: "boolean" }, { code: "canonical" }, { code: "code" }, { code: "date" }, { code: "dateTime" }, { code: "decimal" }, { code: "id" }, { code: "instant" }, { code: "integer" }, { code: "markdown" }, { code: "oid" }, { code: "positiveInt" }, { code: "string" }, { code: "time" }, { code: "unsignedInt" }, { code: "uri" }, { code: "url" }, { code: "uuid" }, { code: "Address" }, { code: "Age" }, { code: "Annotation" }, { code: "Attachment" }, { code: "CodeableConcept" }, { code: "Coding" }, { code: "ContactPoint" }, { code: "Count" }, { code: "Distance" }, { code: "Duration" }, { code: "HumanName" }, { code: "Identifier" }, { code: "Money" }, { code: "Period" }, { code: "Quantity" }, { code: "Range" }, { code: "Ratio" }, { code: "Reference" }, { code: "SampledData" }, { code: "Signature" }, { code: "Timing" }, { code: "ContactDetail" }, { code: "Contributor" }, { code: "DataRequirement" }, { code: "Expression" }, { code: "ParameterDefinition" }, { code: "RelatedArtifact" }, { code: "TriggerDefinition" }, { code: "UsageContext" }, { code: "Dosage" }, { code: "Meta" }] } } }, HumanName: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, use: { type: [{ code: "code" }] }, text: { type: [{ code: "string" }] }, family: { type: [{ code: "string" }] }, given: { max: 9007199254740991, type: [{ code: "string" }] }, prefix: { max: 9007199254740991, type: [{ code: "string" }] }, suffix: { max: 9007199254740991, type: [{ code: "string" }] }, period: { type: [{ code: "Period" }] } } }, Identifier: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, use: { type: [{ code: "code" }] }, type: { type: [{ code: "CodeableConcept" }] }, system: { type: [{ code: "uri" }] }, value: { type: [{ code: "string" }] }, period: { type: [{ code: "Period" }] }, assigner: { type: [{ code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Organization"] }] } } }, MarketingStatus: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, country: { min: 1, type: [{ code: "CodeableConcept" }] }, jurisdiction: { type: [{ code: "CodeableConcept" }] }, status: { min: 1, type: [{ code: "CodeableConcept" }] }, dateRange: { min: 1, type: [{ code: "Period" }] }, restoreDate: { type: [{ code: "dateTime" }] } } }, Meta: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, versionId: { type: [{ code: "id" }] }, lastUpdated: { type: [{ code: "instant" }] }, source: { type: [{ code: "uri" }] }, profile: { max: 9007199254740991, type: [{ code: "canonical", targetProfile: ["http://hl7.org/fhir/StructureDefinition/StructureDefinition"] }] }, security: { max: 9007199254740991, type: [{ code: "Coding" }] }, tag: { max: 9007199254740991, type: [{ code: "Coding" }] }, project: { type: [{ code: "uri" }] }, author: { type: [{ code: "Reference" }] }, account: { type: [{ code: "Reference" }] }, compartment: { max: 9007199254740991, type: [{ code: "Reference" }] } } }, Money: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, currency: { type: [{ code: "code" }] } } }, Narrative: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, status: { min: 1, type: [{ code: "code" }] }, div: { min: 1, type: [{ code: "xhtml" }] } } }, ParameterDefinition: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, name: { type: [{ code: "code" }] }, use: { min: 1, type: [{ code: "code" }] }, min: { type: [{ code: "integer" }] }, max: { type: [{ code: "string" }] }, documentation: { type: [{ code: "string" }] }, type: { min: 1, type: [{ code: "code" }] }, profile: { type: [{ code: "canonical", targetProfile: ["http://hl7.org/fhir/StructureDefinition/StructureDefinition"] }] } } }, Period: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, start: { type: [{ code: "dateTime" }] }, end: { type: [{ code: "dateTime" }] } } }, Population: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, "age[x]": { type: [{ code: "Range" }, { code: "CodeableConcept" }] }, gender: { type: [{ code: "CodeableConcept" }] }, race: { type: [{ code: "CodeableConcept" }] }, physiologicalCondition: { type: [{ code: "CodeableConcept" }] } } }, ProdCharacteristic: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, height: { type: [{ code: "Quantity" }] }, width: { type: [{ code: "Quantity" }] }, depth: { type: [{ code: "Quantity" }] }, weight: { type: [{ code: "Quantity" }] }, nominalVolume: { type: [{ code: "Quantity" }] }, externalDiameter: { type: [{ code: "Quantity" }] }, shape: { type: [{ code: "string" }] }, color: { max: 9007199254740991, type: [{ code: "string" }] }, imprint: { max: 9007199254740991, type: [{ code: "string" }] }, image: { max: 9007199254740991, type: [{ code: "Attachment" }] }, scoring: { type: [{ code: "CodeableConcept" }] } } }, ProductShelfLife: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, identifier: { type: [{ code: "Identifier" }] }, type: { min: 1, type: [{ code: "CodeableConcept" }] }, period: { min: 1, type: [{ code: "Quantity" }] }, specialPrecautionsForStorage: { max: 9007199254740991, type: [{ code: "CodeableConcept" }] } } }, Quantity: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, Range: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, low: { type: [{ code: "Quantity", profile: ["http://hl7.org/fhir/StructureDefinition/SimpleQuantity"] }] }, high: { type: [{ code: "Quantity", profile: ["http://hl7.org/fhir/StructureDefinition/SimpleQuantity"] }] } } }, Ratio: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, numerator: { type: [{ code: "Quantity" }] }, denominator: { type: [{ code: "Quantity" }] } } }, Reference: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, reference: { type: [{ code: "string" }] }, type: { type: [{ code: "uri" }] }, identifier: { type: [{ code: "Identifier" }] }, display: { type: [{ code: "string" }] } } }, RelatedArtifact: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, type: { min: 1, type: [{ code: "code" }] }, label: { type: [{ code: "string" }] }, display: { type: [{ code: "string" }] }, citation: { type: [{ code: "markdown" }] }, url: { type: [{ code: "url" }] }, document: { type: [{ code: "Attachment" }] }, resource: { type: [{ code: "canonical", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Resource"] }] } } }, SampledData: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, origin: { min: 1, type: [{ code: "Quantity", profile: ["http://hl7.org/fhir/StructureDefinition/SimpleQuantity"] }] }, period: { min: 1, type: [{ code: "decimal" }] }, factor: { type: [{ code: "decimal" }] }, lowerLimit: { type: [{ code: "decimal" }] }, upperLimit: { type: [{ code: "decimal" }] }, dimensions: { min: 1, type: [{ code: "positiveInt" }] }, data: { type: [{ code: "string" }] } } }, Signature: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, type: { min: 1, max: 9007199254740991, type: [{ code: "Coding" }] }, when: { min: 1, type: [{ code: "instant" }] }, who: { min: 1, type: [{ code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Practitioner", "http://hl7.org/fhir/StructureDefinition/PractitionerRole", "http://hl7.org/fhir/StructureDefinition/RelatedPerson", "http://hl7.org/fhir/StructureDefinition/Patient", "http://hl7.org/fhir/StructureDefinition/Device", "http://hl7.org/fhir/StructureDefinition/Organization"] }] }, onBehalfOf: { type: [{ code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Practitioner", "http://hl7.org/fhir/StructureDefinition/PractitionerRole", "http://hl7.org/fhir/StructureDefinition/RelatedPerson", "http://hl7.org/fhir/StructureDefinition/Patient", "http://hl7.org/fhir/StructureDefinition/Device", "http://hl7.org/fhir/StructureDefinition/Organization"] }] }, targetFormat: { type: [{ code: "code" }] }, sigFormat: { type: [{ code: "code" }] }, data: { type: [{ code: "base64Binary" }] } } }, SubstanceAmount: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, "amount[x]": { type: [{ code: "Quantity" }, { code: "Range" }, { code: "string" }] }, amountType: { type: [{ code: "CodeableConcept" }] }, amountText: { type: [{ code: "string" }] }, referenceRange: { type: [{ code: "SubstanceAmountReferenceRange" }] } } }, Timing: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, event: { max: 9007199254740991, type: [{ code: "dateTime" }] }, repeat: { type: [{ code: "TimingRepeat" }] }, code: { type: [{ code: "CodeableConcept" }] } } }, TriggerDefinition: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, type: { min: 1, type: [{ code: "code" }] }, name: { type: [{ code: "string" }] }, "timing[x]": { type: [{ code: "Timing" }, { code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/Schedule"] }, { code: "date" }, { code: "dateTime" }] }, data: { max: 9007199254740991, type: [{ code: "DataRequirement" }] }, condition: { type: [{ code: "Expression" }] } } }, UsageContext: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, code: { min: 1, type: [{ code: "Coding" }] }, "value[x]": { min: 1, type: [{ code: "CodeableConcept" }, { code: "Quantity" }, { code: "Range" }, { code: "Reference", targetProfile: ["http://hl7.org/fhir/StructureDefinition/PlanDefinition", "http://hl7.org/fhir/StructureDefinition/ResearchStudy", "http://hl7.org/fhir/StructureDefinition/InsurancePlan", "http://hl7.org/fhir/StructureDefinition/HealthcareService", "http://hl7.org/fhir/StructureDefinition/Group", "http://hl7.org/fhir/StructureDefinition/Location", "http://hl7.org/fhir/StructureDefinition/Organization"] }] } } }, MoneyQuantity: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, SimpleQuantity: { elements: { id: { type: [{ code: "string" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, value: { type: [{ code: "decimal" }] }, comparator: { max: 0, type: [{ code: "code" }] }, unit: { type: [{ code: "string" }] }, system: { type: [{ code: "uri" }] }, code: { type: [{ code: "code" }] } } }, MetadataResource: { elements: { id: { type: [{ code: "string" }] }, meta: { type: [{ code: "Meta" }] }, implicitRules: { type: [{ code: "uri" }] }, language: { type: [{ code: "code" }] }, text: { type: [{ code: "Narrative" }] }, contained: { max: 9007199254740991, type: [{ code: "Resource" }] }, extension: { max: 9007199254740991, type: [{ code: "Extension" }] }, modifierExtension: { max: 9007199254740991, type: [{ code: "Extension" }] }, url: { type: [{ code: "uri" }] }, version: { type: [{ code: "string" }] }, name: { type: [{ code: "string" }] }, title: { type: [{ code: "string" }] }, status: { min: 1, type: [{ code: "code" }] }, experimental: { type: [{ code: "boolean" }] }, date: { type: [{ code: "dateTime" }] }, publisher: { type: [{ code: "string" }] }, contact: { max: 9007199254740991, type: [{ code: "ContactDetail" }] }, description: { type: [{ code: "markdown" }] }, useContext: { max: 9007199254740991, type: [{ code: "UsageContext" }] }, jurisdiction: { max: 9007199254740991, type: [{ code: "CodeableConcept" }] } } }, IdentityProvider: { elements: { authorizeUrl: { min: 1, type: [{ code: "string" }] }, tokenUrl: { min: 1, type: [{ code: "string" }] }, tokenAuthMethod: { type: [{ code: "code" }] }, userInfoUrl: { min: 1, type: [{ code: "string" }] }, clientId: { min: 1, type: [{ code: "string" }] }, clientSecret: { min: 1, type: [{ code: "string" }] }, usePkce: { type: [{ code: "boolean" }] }, useSubject: { type: [{ code: "boolean" }] } } } };
function Lt(r4) {
  return new _t(r4).parse();
}
var Ee = Ur(Lr);
var Bt = /* @__PURE__ */ Object.create(null);
var Br = /* @__PURE__ */ Object.create(null);
function Ft(r4) {
  let e;
  return r4 ? (e = Br[r4], e || (e = Br[r4] = /* @__PURE__ */ Object.create(null))) : e = Ee, e;
}
function qt(r4, e) {
  var _a;
  let t = Array.isArray(r4) ? r4 : ((_a = r4.entry) == null ? void 0 : _a.map((n) => n.resource)) ?? [];
  for (let n of t)
    jt(n, e);
}
function jt(r4, e) {
  if (!(r4 == null ? void 0 : r4.name))
    throw new Error("Failed loading StructureDefinition from bundle");
  if (r4.resourceType !== "StructureDefinition")
    return;
  let t = Lt(r4), n = Ft(e);
  n[r4.name] = t, e && r4.url === e && (Bt[e] = t);
  for (let i of t.innerTypes)
    i.parentType = t, n[i.name] = i;
}
function Gr() {
  return Ee;
}
function Qr(r4) {
  return !!Ee[r4];
}
function be(r4, e) {
  let t = Ft(e)[r4];
  return !t && e && (t = Ft()[r4]), t;
}
function pe(r4, e) {
  let t = be(r4, e);
  if (!t)
    throw new d(b("Unknown data type: " + r4));
  return t;
}
function Hr(r4) {
  let e = Ee[r4];
  return e && Gt(e);
}
function Wr(r4) {
  return !!Bt[r4];
}
function Kr(r4) {
  return Bt[r4];
}
var _t = class {
  constructor(e) {
    var _a;
    if (!((_a = e.snapshot) == null ? void 0 : _a.element) || e.snapshot.element.length === 0)
      throw new Error(`No snapshot defined for StructureDefinition '${e.name}'`);
    this.root = e.snapshot.element[0], this.elements = e.snapshot.element.slice(1), this.elementIndex = /* @__PURE__ */ Object.create(null), this.index = 0, this.resourceSchema = { name: e.name, title: e.title, type: e.type, url: e.url, kind: e.kind, description: Ti(e), elements: {}, constraints: this.parseElementDefinition(this.root).constraints, innerTypes: [], summaryProperties: /* @__PURE__ */ new Set(), mandatoryProperties: /* @__PURE__ */ new Set() }, this.innerTypes = [];
  }
  parse() {
    var _a, _b, _c2, _d, _e2;
    let e = this.next();
    for (; e; ) {
      if (e.sliceName)
        this.parseSliceStart(e);
      else if ((_a = e.id) == null ? void 0 : _a.includes(":")) {
        if ((_b = this.slicingContext) == null ? void 0 : _b.current) {
          let t = Nt(e, this.slicingContext.path);
          this.slicingContext.current.elements[t] = this.parseElementDefinition(e);
        }
      } else {
        let t = this.parseElementDefinition(e);
        this.checkFieldEnter(e, t);
        let n = this.backboneContext;
        for (; n; ) {
          if ((_c2 = e.path) == null ? void 0 : _c2.startsWith(n.path + ".")) {
            n.type.elements[Nt(e, n.path)] = t;
            break;
          }
          n = n.parent;
        }
        if (!n) {
          let i = Nt(e, this.root.path);
          e.isSummary && ((_d = this.resourceSchema.summaryProperties) == null ? void 0 : _d.add(i.replace("[x]", ""))), t.min > 0 && ((_e2 = this.resourceSchema.mandatoryProperties) == null ? void 0 : _e2.add(i.replace("[x]", ""))), this.resourceSchema.elements[i] = t;
        }
        this.checkFieldExit(e);
      }
      e = this.next();
    }
    return this.checkFieldExit(), this.innerTypes.length > 0 && (this.resourceSchema.innerTypes = this.innerTypes), this.resourceSchema;
  }
  checkFieldEnter(e, t) {
    this.isInnerType(e) && this.enterInnerType(e), e.slicing && !this.slicingContext && this.enterSlice(e, t);
  }
  enterInnerType(e) {
    var _a, _b, _c2;
    for (; this.backboneContext && !le((_a = this.backboneContext) == null ? void 0 : _a.path, e.path); )
      this.innerTypes.push(this.backboneContext.type), this.backboneContext = this.backboneContext.parent;
    this.backboneContext = { type: { name: Ut(e), title: e.label, description: e.definition, elements: {}, constraints: this.parseElementDefinition(e).constraints, innerTypes: [] }, path: e.path ?? "", parent: le((_b = this.backboneContext) == null ? void 0 : _b.path, e.path) ? this.backboneContext : (_c2 = this.backboneContext) == null ? void 0 : _c2.parent };
  }
  enterSlice(e, t) {
    var _a, _b, _c2, _d;
    vi(e) && !((_a = this.peek()) == null ? void 0 : _a.sliceName) || (t.slicing = { discriminator: (((_b = e.slicing) == null ? void 0 : _b.discriminator) ?? []).map((n) => {
      if (n.type !== "value" && n.type !== "pattern" && n.type !== "type")
        throw new Error(`Unsupported slicing discriminator type: ${n.type}`);
      return { path: n.path, type: n.type };
    }), slices: [], ordered: ((_c2 = e.slicing) == null ? void 0 : _c2.ordered) ?? false, rule: (_d = e.slicing) == null ? void 0 : _d.rules }, this.slicingContext = { field: t.slicing, path: e.path ?? "" });
  }
  checkFieldExit(e = void 0) {
    var _a;
    if (this.backboneContext && !le(this.backboneContext.path, e == null ? void 0 : e.path))
      if (this.backboneContext.parent)
        do
          this.innerTypes.push(this.backboneContext.type), this.backboneContext = this.backboneContext.parent;
        while (this.backboneContext && !le(this.backboneContext.path, e == null ? void 0 : e.path));
      else
        this.innerTypes.push(this.backboneContext.type), delete this.backboneContext;
    this.slicingContext && !le(this.slicingContext.path, e == null ? void 0 : e.path) && (((_a = this.slicingContext) == null ? void 0 : _a.current) && this.slicingContext.field.slices.push(this.slicingContext.current), delete this.slicingContext);
  }
  next() {
    let e = this.peek();
    if (e)
      return this.index++, e;
  }
  peek() {
    let e = this.elements[this.index];
    if (e) {
      if (this.elementIndex[e.path ?? ""] = e, e.contentReference) {
        let t = this.elementIndex[e.contentReference.slice(e.contentReference.indexOf("#") + 1)];
        return t ? { ...t, id: e.id, path: e.path, min: e.min ?? t.min, max: e.max ?? t.max, contentReference: e.contentReference, definition: e.definition } : void 0;
      }
      return e;
    }
  }
  isInnerType(e) {
    var _a;
    let t = this.peek();
    return !!(le(e == null ? void 0 : e.path, t == null ? void 0 : t.path) && ((_a = e.type) == null ? void 0 : _a.some((n) => ["BackboneElement", "Element"].includes(n.code))));
  }
  parseSliceStart(e) {
    if (!this.slicingContext)
      throw new Error(`Invalid slice start before discriminator: ${e.sliceName} (${e.id})`);
    this.slicingContext.current && this.slicingContext.field.slices.push(this.slicingContext.current), this.slicingContext.current = { name: e.sliceName ?? "", path: e.path ?? "", definition: e.definition, type: this.parseElementDefinitionType(e), elements: {}, min: e.min ?? 0, max: e.max === "*" ? Number.POSITIVE_INFINITY : Number.parseInt(e.max, 10), binding: e.binding };
  }
  parseElementDefinitionType(e) {
    return (e.type ?? []).map((t) => {
      var _a;
      let n;
      return (t.code === "BackboneElement" || t.code === "Element") && (n = Ut(e)), n || (n = (_a = $t(t, "http://hl7.org/fhir/StructureDefinition/structuredefinition-fhir-type")) == null ? void 0 : _a.valueUrl), n || (n = t.code ?? ""), { code: n, targetProfile: t.targetProfile, profile: t.profile };
    });
  }
  parseElementDefinition(e) {
    var _a, _b;
    let t = jr(e.max), n = ((_a = e.base) == null ? void 0 : _a.max) ? jr(e.base.max) : t, i = { type: "ElementDefinition", value: e };
    return { description: e.definition || "", path: e.path || ((_b = e.base) == null ? void 0 : _b.path) || "", min: e.min ?? 0, max: t, isArray: n > 1, constraints: (e.constraint ?? []).map((o) => ({ key: o.key ?? "", severity: o.severity ?? "error", expression: o.expression ?? "", description: o.human ?? "" })), type: this.parseElementDefinitionType(e), fixed: $r(P(i, "fixed[x]")), pattern: $r(P(i, "pattern[x]")), binding: e.binding };
  }
};
function Oa(r4, e) {
  var _a;
  if (!r4)
    return;
  let t = [];
  for (let n of e) {
    t.push("_" + n);
    let i = Ee[r4.resourceType].elements[n + "[x]"];
    i && t.push(...i.type.map((o) => n + C(o.code)));
  }
  for (let n of Object.getOwnPropertyNames(r4))
    !e.includes(n) && !t.includes(n) && !gi.includes(n) && Object.defineProperty(r4, n, { enumerable: false, writable: false, value: void 0 });
  return r4.meta = { ...r4.meta, tag: ((_a = r4.meta) == null ? void 0 : _a.tag) ? r4.meta.tag.concat(qr) : [qr] }, r4;
}
var qr = { system: "http://hl7.org/fhir/v3/ObservationValue", code: "SUBSETTED" };
var gi = ["resourceType", "id", "meta"];
function jr(r4) {
  return r4 === "*" ? Number.POSITIVE_INFINITY : Number.parseInt(r4, 10);
}
function Nt(r4, e = "") {
  return xi(r4.path, e);
}
function xi(r4, e) {
  return r4 ? e && r4.startsWith(e) ? r4.substring(e.length + 1) : r4 : "";
}
function le(r4, e) {
  return !r4 || !e ? false : e.startsWith(r4 + ".") || e === r4;
}
function $r(r4) {
  return Array.isArray(r4) && r4.length > 0 ? r4[0] : S(r4) ? void 0 : r4;
}
function vi(r4) {
  var _a, _b;
  let e = (_a = r4.slicing) == null ? void 0 : _a.discriminator;
  return !!(((_b = r4.type) == null ? void 0 : _b.some((t) => t.code === "Extension")) && (e == null ? void 0 : e.length) === 1 && e[0].type === "value" && e[0].path === "url");
}
function Ti(r4) {
  let e = r4.description;
  return (e == null ? void 0 : e.startsWith(`Base StructureDefinition for ${r4.name} Type: `)) && (e = e.substring(`Base StructureDefinition for ${r4.name} Type: `.length)), e;
}
function Ht(r4, e, t, n) {
  new Qt(r4, e, t, n).crawl();
}
var Qt = class {
  constructor(e, t, n, i) {
    this.rootResource = e, this.visitor = t, n ? this.schema = n : this.schema = pe(e.resourceType), i ? this.initialPath = i : this.initialPath = e.resourceType;
  }
  crawl() {
    this.crawlObject(y(this.rootResource), this.schema, this.initialPath);
  }
  crawlObject(e, t, n) {
    let i = _(e.value);
    i && this.visitor.onEnterResource && this.visitor.onEnterResource(n, e, t), this.visitor.onEnterObject && this.visitor.onEnterObject(n, e, t);
    for (let o of Object.keys(t.elements))
      this.crawlProperty(e, o, t, `${n}.${o}`);
    this.visitor.onExitObject && this.visitor.onExitObject(n, e, t), i && this.visitor.onExitResource && this.visitor.onExitResource(n, e, t);
  }
  crawlProperty(e, t, n, i) {
    let o = Re(e, t);
    this.visitor.visitProperty && this.visitor.visitProperty(e, t, i, o, n);
    for (let s of o)
      if (s)
        for (let a of je(s))
          this.crawlPropertyValue(a, i);
  }
  crawlPropertyValue(e, t) {
    if (!qe(e.type.charAt(0))) {
      let n = pe(e.type);
      this.crawlObject(e, n, t);
    }
  }
};
function Re(r4, e, t) {
  if (e === "$this")
    return [r4];
  let [n, ...i] = e.split("."), o = [P(r4, n, t)];
  for (let s of i) {
    let a = [];
    for (let c of o)
      if (Array.isArray(c))
        for (let u of c)
          a.push(P(u, s, t));
      else
        c !== void 0 && a.push(P(c, s, t));
    o = a;
  }
  return o;
}
var zr = { base64Binary: "string", boolean: "boolean", canonical: "string", code: "string", date: "string", dateTime: "string", decimal: "number", id: "string", instant: "string", integer: "number", markdown: "string", oid: "string", positiveInt: "number", string: "string", time: "string", unsignedInt: "number", uri: "string", url: "string", uuid: "string", xhtml: "string", "http://hl7.org/fhirpath/System.String": "string" };
var $e = { base64Binary: /^([A-Za-z\d+/]{4})*([A-Za-z\d+/]{2}==|[A-Za-z\d+/]{3}=)?$/, canonical: /^\S*$/, code: /^[^\s]+( [^\s]+)*$/, date: /^(\d(\d(\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2]\d|3[0-1]))?)?$/, dateTime: /^(\d(\d(\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2]\d|3[0-1])(T([01]\d|2[0-3])(:[0-5]\d:([0-5]\d|60)(\.\d{1,9})?)?)?)?(Z|[+-]((0\d|1[0-3]):[0-5]\d|14:00)?)?)?$/, id: /^[A-Za-z0-9\-.]{1,64}$/, instant: /^(\d(\d(\d[1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2]\d|3[0-1])T([01]\d|2[0-3]):[0-5]\d:([0-5]\d|60)(\.\d{1,9})?(Z|[+-]((0\d|1[0-3]):[0-5]\d|14:00))$/, markdown: /^[\s\S]+$/, oid: /^urn:oid:[0-2](\.(0|[1-9]\d*))+$/, string: /^[\s\S]+$/, time: /^([01]\d|2[0-3]):[0-5]\d:([0-5]\d|60)(\.\d{1,9})?$/, uri: /^\S*$/, url: /^\S*$/, uuid: /^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/, xhtml: /.*/ };
var Si = { "ele-1": true, "dom-3": true, "org-1": true, "sdf-19": true };
function rc(r4, e) {
  return new Wt(r4.resourceType, r4, e).validate();
}
var Wt = class {
  constructor(e, t, n) {
    this.issues = [], this.rootResource = t, this.currentResource = [t], (n == null ? void 0 : n.profile) ? this.schema = Lt(n.profile) : this.schema = pe(e);
  }
  validate() {
    let e = this.rootResource.resourceType;
    if (!e)
      throw new d(m("Missing resource type"));
    this.constraintsCheck(y(this.rootResource), this.schema, e), Kt(this.rootResource, e, this.issues), Ht(this.rootResource, this, this.schema);
    let t = this.issues, n = false;
    for (let i of t)
      i.severity === "error" && (n = true);
    if (n)
      throw new d({ resourceType: "OperationOutcome", issue: t });
    return t;
  }
  onExitObject(e, t, n) {
    this.checkAdditionalProperties(t, n.elements, e);
  }
  onEnterResource(e, t) {
    this.currentResource.push(t.value);
  }
  onExitResource() {
    this.currentResource.pop();
  }
  visitProperty(e, t, n, i, o) {
    var _a;
    let s = o.elements[t];
    if (!s)
      throw new Error(`Missing element validation schema for ${t}`);
    for (let a of i) {
      if (!this.checkPresence(a, s, n))
        return;
      let c;
      if (s.isArray) {
        if (!Array.isArray(a)) {
          this.issues.push(g(n, "Expected array of values for property"));
          return;
        }
        c = a;
      } else {
        if (Array.isArray(a)) {
          this.issues.push(g(n, "Expected single value for property"));
          return;
        }
        c = [a];
      }
      (c.length < s.min || c.length > s.max) && this.issues.push(g(s.path, `Invalid number of values: expected ${s.min}..${Number.isFinite(s.max) ? s.max : "*"}, but found ${c.length}`)), Jr(a, s) || this.issues.push(g(n, "Value did not match expected pattern"));
      let u = s.slicing ? Object.fromEntries(s.slicing.slices.map((p) => [p.name, 0])) : void 0;
      for (let p of c) {
        this.constraintsCheck(p, s, n), this.referenceTypeCheck(p, s, n), this.checkPropertyValue(p, n);
        let x = Ri(p, s.slicing);
        x && u && (u[x] += 1);
      }
      this.validateSlices((_a = s.slicing) == null ? void 0 : _a.slices, u, n);
    }
  }
  checkPresence(e, t, n) {
    return e === void 0 ? (t.min > 0 && this.issues.push(g(n, "Missing required property")), false) : S(e) ? (this.issues.push(g(n, "Invalid empty value")), false) : true;
  }
  checkPropertyValue(e, t) {
    qe(e.type.charAt(0)) && this.validatePrimitiveType(e, t);
  }
  validateSlices(e, t, n) {
    if (!(!e || !t))
      for (let i of e) {
        let o = t[i.name];
        (o < i.min || o > i.max) && this.issues.push(g(n, `Incorrect number of values provided for slice '${i.name}': expected ${i.min}..${Number.isFinite(i.max) ? i.max : "*"}, but found ${o}`));
      }
  }
  checkAdditionalProperties(e, t, n) {
    let i = e.value;
    if (!i)
      return;
    let o = {};
    for (let s of Object.keys(i)) {
      if (s === "resourceType")
        continue;
      let a = bi(e, s, t);
      if (a) {
        o[a] && this.issues.push(ue("warning", "structure", `Duplicate choice of type property "${a}"`, a)), o[a] = true;
        continue;
      }
      !(s in t) && !(s.startsWith("_") && s.slice(1) in t) && this.issues.push(g(`${n}.${s}`, `Invalid additional property "${s}"`));
    }
  }
  constraintsCheck(e, t, n) {
    let i = t.constraints;
    if (i) {
      for (let o of i)
        if (o.severity === "error" && !(o.key in Si) && !this.isExpressionTrue(o, e, n)) {
          this.issues.push(Fr(n, o));
          return;
        }
    }
  }
  referenceTypeCheck(e, t, n) {
    var _a;
    if (e.type !== "Reference")
      return;
    let i = e.value;
    if (!Y(i))
      return;
    let o = i.reference.split("/")[0];
    if (!o)
      return;
    let s = (_a = t.type.find((v) => v.code === "Reference")) == null ? void 0 : _a.targetProfile;
    if (!s)
      return;
    let a = wr + "/fhir/StructureDefinition/", c = a + "Resource", u = a + o, p = "https://medplum.com/fhir/StructureDefinition/", x = p + o;
    for (let v of s)
      if (v === c || v === u || v === x || !v.startsWith(a) && !v.startsWith(p))
        return;
    this.issues.push(ue("warning", "structure", `Invalid reference for "${n}", got "${o}", expected "${s.join('", "')}"`, n));
  }
  isExpressionTrue(e, t, n) {
    try {
      let i = $(e.expression, [t], { "%context": t, "%resource": y(this.currentResource[this.currentResource.length - 1]), "%rootResource": y(this.rootResource), "%ucum": y(Pr) });
      return i.length === 1 && i[0].value === true;
    } catch (i) {
      return this.issues.push(_r(n, "Error evaluating invariant expression", i, { fhirpath: e.expression })), false;
    }
  }
  validatePrimitiveType(e, t) {
    let [n, i] = Ci(e);
    if (n) {
      let { type: o, value: s } = n;
      if (!(o in zr)) {
        this.issues.push(g(t, `Invalid JSON type: ${o} is not a valid FHIR type`));
        return;
      }
      let a = zr[o];
      if (typeof s !== a) {
        s !== null && this.issues.push(g(t, `Invalid JSON type: expected ${a}, but got ${typeof s}`));
        return;
      }
      a === "string" ? this.validateString(s, o, t) : a === "number" && this.validateNumber(s, o, t);
    }
    i && Ht(i.value, this, pe("Element"), t);
  }
  validateString(e, t, n) {
    if (!e.trim()) {
      this.issues.push(g(n, "String must contain non-whitespace content"));
      return;
    }
    let i = $e[t];
    i && !i.exec(e) && this.issues.push(g(n, "Invalid " + t + " format"));
  }
  validateNumber(e, t, n) {
    Number.isNaN(e) || !Number.isFinite(e) ? this.issues.push(g(n, "Invalid numeric value")) : Ei(t) && !Number.isInteger(e) ? this.issues.push(g(n, "Expected number to be an integer")) : t === l.positiveInt && e <= 0 ? this.issues.push(g(n, "Expected number to be positive")) : t === l.unsignedInt && e < 0 && this.issues.push(g(n, "Expected number to be non-negative"));
  }
};
function Ei(r4) {
  return r4 === l.integer || r4 === l.positiveInt || r4 === l.unsignedInt;
}
function bi(r4, e, t) {
  e.startsWith("_") && (e = e.slice(1));
  let n = e.split(/(?=[A-Z])/g), i = "";
  for (let o of n) {
    i += o;
    let s = i + "[x]";
    if (t[s])
      return P(r4, i) ? s : void 0;
  }
}
function Kt(r4, e, t) {
  var _a;
  for (let [n, i] of Object.entries(r4)) {
    let o = `${e}.${n}`, s = n.startsWith("_") ? n.slice(1) : `_${n}`;
    if (i === null)
      t.push(g(o, "Invalid null value"));
    else if (Array.isArray(i))
      for (let a = 0; a < i.length; a++)
        i[a] === void 0 ? t.push(g(`${o}[${a}]`, "Invalid undefined value")) : i[a] === null && !((_a = r4[s]) == null ? void 0 : _a[a]) ? t.push(g(`${o}[${a}]`, "Invalid null value")) : i[a] && Kt(i[a], `${o}[${a}]`, t);
    else
      typeof i == "object" && Kt(i, o, t);
  }
}
function Jr(r4, e) {
  return !(e.pattern && !Qe(r4, e.pattern) || e.fixed && !Ge(r4, e.fixed));
}
function zt(r4, e, t, n) {
  if (Array.isArray(r4))
    return false;
  let i = (n ?? t.elements)[e.path], o = t.type;
  switch (e.type) {
    case "value":
    case "pattern":
      if (!r4 || !i)
        return false;
      if (Jr(r4, i))
        return true;
      break;
    case "type":
      return !r4 || !(o == null ? void 0 : o.length) ? false : o.some((s) => s.code === r4.type);
  }
  return false;
}
function Ri(r4, e) {
  if (e) {
    for (let t of e.slices)
      if (e.discriminator.every((n) => {
        var _a;
        return (_a = je(Re(r4, n.path))) == null ? void 0 : _a.some((i) => zt(i, n, t));
      }))
        return t.name;
  }
}
function Ci(r4) {
  if (typeof r4.value != "object" || !r4.value)
    return [r4, void 0];
  let e = r4.value.valueOf();
  if (e === r4.value)
    return [void 0, { type: "Element", value: r4.value }];
  let t = new Set(Object.keys(e)), n = Object.entries(r4.value).filter(([o, s]) => !t.has(o)), i = n.length > 0 ? Object.fromEntries(n) : void 0;
  return [{ type: r4.type, value: e }, { type: "Element", value: i }];
}
function f(r4) {
  return [{ type: l.boolean, value: r4 }];
}
function y(r4) {
  return r4 == null ? { type: "undefined", value: void 0 } : Number.isSafeInteger(r4) ? { type: l.integer, value: r4 } : typeof r4 == "number" ? { type: l.decimal, value: r4 } : typeof r4 == "boolean" ? { type: l.boolean, value: r4 } : typeof r4 == "string" ? { type: l.string, value: r4 } : A(r4) ? { type: l.Quantity, value: r4 } : _(r4) ? { type: r4.resourceType, value: r4 } : { type: l.BackboneElement, value: r4 };
}
function N(r4) {
  return r4.length === 0 ? false : !!r4[0].value;
}
function U(r4, e) {
  if (r4.length !== 0) {
    if (r4.length === 1 && (!e || r4[0].type === e))
      return r4[0];
    throw new Error(`Expected singleton of type ${e}, but found ${JSON.stringify(r4)}`);
  }
}
function P(r4, e, t) {
  if (!r4.value)
    return;
  let n = ze(r4.type, e, t == null ? void 0 : t.profileUrl);
  return n ? Pi(r4, e, n) : wi(r4, e);
}
function Pi(r4, e, t) {
  let n = r4.value, i = t.type;
  if (!i || i.length === 0)
    return;
  let o, s = "undefined", a;
  if (t.path.endsWith("[x]")) {
    let c = t.path.split(".").pop().replace("[x]", "");
    for (let u of i) {
      let p = c + C(u.code);
      if (o = n[p], a = n["_" + p], o !== void 0 || a !== void 0) {
        s = u.code;
        break;
      }
    }
  } else
    console.assert(i.length === 1, "Expected single type", t.path), o = n[e], s = i[0].code, a = n["_" + e];
  if (a)
    if (Array.isArray(o))
      for (let c = 0; c < Math.max(o.length, a.length); c++)
        o[c] = tn(o[c], a[c]);
    else
      o = tn(o, a);
  if (!S(o))
    return (s === "Element" || s === "BackboneElement") && (s = t.type[0].code), Array.isArray(o) ? o.map((c) => Yr(c, s)) : Yr(o, s);
}
function Yr(r4, e) {
  return e === "Resource" && _(r4) && (e = r4.resourceType), { type: e, value: r4 };
}
function wi(r4, e) {
  let t = r4.value;
  if (!t || typeof t != "object")
    return;
  let n;
  if (e in t)
    n = t[e];
  else
    for (let i in l) {
      let o = e + C(i);
      if (o in t) {
        n = t[o];
        break;
      }
    }
  if (!S(n))
    return Array.isArray(n) ? n.map(y) : y(n);
}
function We(r4) {
  let e = [];
  for (let t of r4) {
    let n = false;
    for (let i of e)
      if (N(rn(t, i))) {
        n = true;
        break;
      }
    n || e.push(t);
  }
  return e;
}
function Jt(r4) {
  return f(!N(r4));
}
function Yt(r4, e) {
  return r4.length === 0 || e.length === 0 ? [] : r4.length !== e.length ? f(false) : f(r4.every((t, n) => N(rn(t, e[n]))));
}
function rn(r4, e) {
  var _a, _b;
  let t = (_a = r4.value) == null ? void 0 : _a.valueOf(), n = (_b = e.value) == null ? void 0 : _b.valueOf();
  return typeof t == "number" && typeof n == "number" ? f(Math.abs(t - n) < 1e-8) : A(t) && A(n) ? f(sn(t, n)) : f(typeof t == "object" && typeof n == "object" ? Xt(r4, e) : t === n);
}
function Zt(r4, e) {
  return r4.length === 0 && e.length === 0 ? f(true) : r4.length !== e.length ? f(false) : (r4.sort(Zr), e.sort(Zr), f(r4.every((t, n) => N(Ai(t, e[n])))));
}
function Ai(r4, e) {
  let { type: t, value: n } = r4, { type: i, value: o } = e, s = n == null ? void 0 : n.valueOf(), a = o == null ? void 0 : o.valueOf();
  return typeof s == "number" && typeof a == "number" ? f(Math.abs(s - a) < 0.01) : A(s) && A(a) ? f(sn(s, a)) : f(t === "Coding" && i === "Coding" ? typeof s != "object" || typeof a != "object" ? false : s.code === a.code && s.system === a.system : typeof s == "object" && typeof a == "object" ? Xt({ ...s, id: void 0 }, { ...a, id: void 0 }) : typeof s == "string" && typeof a == "string" ? s.toLowerCase() === a.toLowerCase() : s === a);
}
function Zr(r4, e) {
  var _a, _b;
  let t = (_a = r4.value) == null ? void 0 : _a.valueOf(), n = (_b = e.value) == null ? void 0 : _b.valueOf();
  return typeof t == "number" && typeof n == "number" ? t - n : typeof t == "string" && typeof n == "string" ? t.localeCompare(n) : 0;
}
function Ke(r4, e) {
  let { value: t } = r4;
  if (t == null)
    return false;
  switch (e) {
    case "Boolean":
      return typeof t == "boolean";
    case "Decimal":
    case "Integer":
      return typeof t == "number";
    case "Date":
      return nn(t);
    case "DateTime":
      return He(t);
    case "Time":
      return typeof t == "string" && !!/^T\d/.exec(t);
    case "Period":
      return on(t);
    case "Quantity":
      return A(t);
    default:
      return typeof t == "object" && (t == null ? void 0 : t.resourceType) === e;
  }
}
function nn(r4) {
  return typeof r4 == "string" && !!$e.date.exec(r4);
}
function He(r4) {
  return typeof r4 == "string" && !!$e.dateTime.exec(r4);
}
function on(r4) {
  return !!(r4 && typeof r4 == "object" && ("start" in r4 && He(r4.start) || "end" in r4 && He(r4.end)));
}
function cc(r4) {
  if (r4) {
    if (nn(r4))
      return { start: Xr(r4, "0000-00-00T00:00:00.000Z"), end: Xr(r4, "xxxx-12-31T23:59:59.999Z") };
    if (He(r4))
      return { start: r4, end: r4 };
    if (on(r4))
      return r4;
  }
}
function Xr(r4, e) {
  return r4 + e.substring(r4.length);
}
function A(r4) {
  return !!(r4 && typeof r4 == "object" && "value" in r4 && typeof r4.value == "number");
}
function sn(r4, e) {
  return Math.abs(r4.value - e.value) < 0.01 && (r4.unit === e.unit || r4.code === e.code || r4.unit === e.code || r4.code === e.unit);
}
function Xt(r4, e) {
  let t = Object.keys(r4), n = Object.keys(e);
  if (t.length !== n.length)
    return false;
  for (let i of t) {
    let o = r4[i], s = e[i];
    if (en(o) && en(s)) {
      if (!Xt(o, s))
        return false;
    } else if (o !== s)
      return false;
  }
  return true;
}
function en(r4) {
  return r4 !== null && typeof r4 == "object";
}
function tn(r4, e) {
  if (e) {
    if (typeof e != "object")
      throw new Error("Primitive extension must be an object");
    return Ii(r4 ?? {}, e);
  }
  return r4;
}
function Ii(r4, e) {
  return delete e.__proto__, delete e.constructor, Object.assign(r4, e);
}
function Z(r4) {
  let e = X(r4), t = Oi(r4);
  return t === e ? { reference: e } : { reference: e, display: t };
}
function X(r4) {
  return Y(r4) ? r4.reference : `${r4.resourceType}/${r4.id}`;
}
function Je(r4) {
  if (r4)
    return Y(r4) ? r4.reference.split("/")[1] : r4.id;
}
function mc(r4) {
  if ((r4 == null ? void 0 : r4.reference) === void 0)
    throw new d(m("Reference missing reference property."));
  let [e, t] = r4.reference.split("/");
  if (e === "" || t === "" || t === void 0)
    throw new d(m("Unable to parse reference string."));
  return [e, t];
}
function ki(r4) {
  return r4.resourceType === "Patient" || r4.resourceType === "Practitioner" || r4.resourceType === "RelatedPerson";
}
function Oi(r4) {
  var _a;
  if (ki(r4)) {
    let e = Vi(r4);
    if (e)
      return e;
  }
  if (r4.resourceType === "Device") {
    let e = Di(r4);
    if (e)
      return e;
  }
  return r4.resourceType === "Observation" && "code" in r4 && ((_a = r4.code) == null ? void 0 : _a.text) ? r4.code.text : r4.resourceType === "User" && r4.email ? r4.email : "name" in r4 && r4.name && typeof r4.name == "string" ? r4.name : X(r4);
}
function Vi(r4) {
  let e = r4.name;
  if (e && e.length > 0)
    return Ze(e[0]);
}
function Di(r4) {
  let e = r4.deviceName;
  if (e && e.length > 0)
    return e[0].name;
}
function hc(r4) {
  if (!("photo" in r4))
    return;
  let e = r4.photo;
  if (e)
    if (Array.isArray(e))
      for (let t of e) {
        let n = an(t);
        if (n)
          return n;
      }
    else
      return an(e);
}
function an(r4) {
  if (r4.url && r4.contentType && r4.contentType.startsWith("image/"))
    return r4.url;
}
function yc(r4) {
  return r4 ? new Date(r4) : void 0;
}
function Ye(r4, e) {
  let t = new Date(r4);
  t.setUTCHours(0, 0, 0, 0);
  let n = e ? new Date(e) : /* @__PURE__ */ new Date();
  n.setUTCHours(0, 0, 0, 0);
  let i = t.getUTCFullYear(), o = t.getUTCMonth(), s = t.getUTCDate(), a = n.getUTCFullYear(), c = n.getUTCMonth(), u = n.getUTCDate(), p = a - i;
  (c < o || c === o && u < s) && p--;
  let x = a * 12 + c - (i * 12 + o);
  u < s && x--;
  let v = Math.floor((n.getTime() - t.getTime()) / (1e3 * 60 * 60 * 24));
  return { years: p, months: x, days: v };
}
function gc(r4, e) {
  let { years: t, months: n, days: i } = Ye(r4, e);
  return t >= 2 ? t.toString().padStart(3, "0") + "Y" : n >= 1 ? n.toString().padStart(3, "0") + "M" : i.toString().padStart(3, "0") + "D";
}
function xc(r4) {
  let e = {};
  return cn(r4.item, e), e;
}
function cn(r4, e) {
  if (r4)
    for (let t of r4)
      t.linkId && t.answer && t.answer.length > 0 && (e[t.linkId] = t.answer[0]), cn(t.item, e);
}
function vc(r4) {
  let e = {};
  return un(r4.item, e), e;
}
function un(r4, e) {
  if (r4)
    for (let t of r4)
      t.linkId && t.answer && t.answer.length > 0 && (e[t.linkId] = t.answer), un(t.item, e);
}
function Tc(r4, e) {
  let t = r4.identifier;
  if (!t)
    return;
  let n = Array.isArray(t) ? t : [t];
  for (let i of n)
    if (i.system === e)
      return i.value;
}
function Sc(r4, e, t) {
  let n = r4.identifier;
  if (!n) {
    r4.identifier = [{ system: e, value: t }];
    return;
  }
  for (let i of n)
    if (i.system === e) {
      i.value = t;
      return;
    }
  n.push({ system: e, value: t });
}
function Ec(r4, ...e) {
  let t = $t(r4, ...e);
  if (!t)
    return;
  let n = P({ type: "Extension", value: t }, "value[x]");
  if (n)
    return Array.isArray(n) ? n[0].value : n.value;
}
function $t(r4, ...e) {
  var _a;
  let t = r4;
  for (let n = 0; n < e.length && t; n++)
    t = (_a = t == null ? void 0 : t.extension) == null ? void 0 : _a.find((i) => i.url === e[n]);
  return t;
}
function ln(r4, e) {
  return JSON.stringify(r4, Mi, e ? 2 : void 0);
}
function Mi(r4, e) {
  return !Ni(r4) && S(e) ? void 0 : e;
}
function Ni(r4) {
  return !!/\d+$/.exec(r4);
}
function S(r4) {
  if (r4 == null)
    return true;
  let e = typeof r4;
  return e === "string" || e === "object" ? !G(r4) : false;
}
function G(r4) {
  if (r4 == null)
    return false;
  let e = typeof r4;
  return e === "string" && r4 !== "" || e === "object" && ("length" in r4 && r4.length > 0 || Object.keys(r4).length > 0);
}
function Ge(r4, e, t) {
  return r4 === e || S(r4) && S(e) ? true : S(r4) || S(e) ? false : Array.isArray(r4) && Array.isArray(e) ? Fi(r4, e) : Array.isArray(r4) || Array.isArray(e) ? false : O(r4) && O(e) ? _i(r4, e, t) : (O(r4) || O(e), false);
}
function Fi(r4, e) {
  if (r4.length !== e.length)
    return false;
  for (let t = 0; t < r4.length; t++)
    if (!Ge(r4[t], e[t]))
      return false;
  return true;
}
function _i(r4, e, t) {
  let n = /* @__PURE__ */ new Set();
  Object.keys(r4).forEach((i) => n.add(i)), Object.keys(e).forEach((i) => n.add(i)), t === "meta" && (n.delete("versionId"), n.delete("lastUpdated"), n.delete("author"));
  for (let i of n) {
    let o = r4[i], s = e[i];
    if (!Ge(o, s, i))
      return false;
  }
  return true;
}
function Qe(r4, e) {
  return S(r4) ? true : S(e) ? false : Array.isArray(r4) && Array.isArray(e) ? Ui(r4, e) : Array.isArray(r4) || Array.isArray(e) ? false : O(r4) && O(e) ? Li(r4, e) : O(r4) || O(e) ? false : r4 === e;
}
function Ui(r4, e) {
  return e.every((t) => r4.some((n) => Qe(n, t)));
}
function Li(r4, e) {
  return Object.entries(e).every(([t, n]) => t in r4 && Qe(r4[t], n));
}
function ee(r4) {
  return r4 === void 0 ? r4 : JSON.parse(JSON.stringify(r4));
}
function bc(r4) {
  return !!/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/i.exec(r4);
}
function O(r4) {
  return r4 !== null && typeof r4 == "object";
}
function pn(r4) {
  return r4.every((e) => typeof e == "string");
}
var dn = [];
for (let r4 = 0; r4 < 256; r4++)
  dn.push(r4.toString(16).padStart(2, "0"));
function fn(r4) {
  let e = new Uint8Array(r4), t = new Array(e.length);
  for (let n = 0; n < e.length; n++)
    t[n] = dn[e[n]];
  return t.join("");
}
function mn(r4) {
  let e = new Uint8Array(r4), t = [];
  for (let n = 0; n < e.length; n++)
    t[n] = String.fromCharCode(e[n]);
  return window.btoa(t.join(""));
}
function C(r4) {
  return r4 ? r4.charAt(0).toUpperCase() + r4.substring(1) : "";
}
function qe(r4) {
  return r4 === r4.toLowerCase() && r4 !== r4.toUpperCase();
}
function tr(r4) {
  return r4.length > 0 && r4.startsWith(r4[0].toUpperCase());
}
function de(r4, e) {
  let t = r4 + ".";
  if (e.startsWith(t))
    return e.slice(t.length);
}
function er(r4, e) {
  var _a, _b;
  return (_b = (_a = r4.coding) == null ? void 0 : _a.find((t) => t.system === e)) == null ? void 0 : _b.code;
}
function Rc(r4, e, t) {
  r4.coding || (r4.coding = []);
  let n = r4.coding.find((i) => i.system === e);
  n ? n.code = t : r4.coding.push({ system: e, code: t });
}
function Cc(r4, e, t, n) {
  var _a;
  return (_a = r4.qualifiedInterval) == null ? void 0 : _a.find((i) => {
    var _a2;
    return hn(i, e) && ji(i, t, (_a2 = r4.quantitativeDetails) == null ? void 0 : _a2.decimalPrecision) && (n === void 0 || i.category === n);
  });
}
function Pc(r4, e, t) {
  var _a;
  return (_a = r4.qualifiedInterval) == null ? void 0 : _a.find((n) => hn(n, e) && t.includes(n.condition));
}
function hn(r4, e) {
  return Bi(r4, e) && qi(r4, e);
}
function Bi(r4, e) {
  return !r4.gender || r4.gender === e.gender;
}
function qi(r4, e) {
  return !r4.age || yn(Ye(e.birthDate).years, r4.age);
}
function ji(r4, e, t) {
  return !!r4.range && yn(e, r4.range, t);
}
function yn(r4, e, t) {
  var _a, _b;
  return (((_a = e.low) == null ? void 0 : _a.value) === void 0 || Gi(r4, e.low.value, t)) && (((_b = e.high) == null ? void 0 : _b.value) === void 0 || $i(r4, e.high.value, t));
}
function wc(r4, e) {
  return parseFloat(r4.toFixed(e));
}
function Ac(r4, e, t) {
  return L(r4, t) === L(e, t);
}
function Ic(r4, e, t) {
  return L(r4, t) < L(e, t);
}
function kc(r4, e, t) {
  return L(r4, t) > L(e, t);
}
function $i(r4, e, t) {
  return L(r4, t) <= L(e, t);
}
function Gi(r4, e, t) {
  return L(r4, t) >= L(e, t);
}
function L(r4, e) {
  return e === void 0 ? r4 : Math.round(r4 * Math.pow(10, e));
}
function Oc(r4, e, t) {
  return r4.find((n) => typeof e == "string" ? er(n.code || {}, t) === e : er(n.code || {}, t) === er(e, t));
}
function je(r4) {
  if (r4)
    return Array.isArray(r4) ? r4 : [r4];
}
var rr = (r4) => new Promise((e) => {
  setTimeout(e, r4);
});
function Vc(r4, e, t) {
  let n = [];
  for (let i = 0; i < t - 1; i++) {
    let o = r4.indexOf(e);
    if (o < 0)
      break;
    n.push(r4.slice(0, o)), r4 = r4.slice(o + e.length);
  }
  return n.push(r4), n;
}
function Dc(r4) {
  let e, t = false;
  return function() {
    return t || (e = r4(), t = true), e;
  };
}
function fe(r4, e) {
  return r4 ? (r4.push(e), r4) : [e];
}
function gn(r4, e) {
  return new URL(r4, e).toString().replace("http://", "ws://").replace("https://", "wss://");
}
function Fc(r4, e) {
  let t = [];
  if (r4.line && t.push(...r4.line), r4.city || r4.state || r4.postalCode) {
    let n = [];
    r4.city && n.push(r4.city), r4.state && n.push(r4.state), r4.postalCode && n.push(r4.postalCode), t.push(n.join(", "));
  }
  return r4.use && ((e == null ? void 0 : e.all) || (e == null ? void 0 : e.use)) && t.push("[" + r4.use + "]"), t.join((e == null ? void 0 : e.lineSeparator) ?? ", ").trim();
}
function Ze(r4, e) {
  let t = [];
  if (r4.prefix && (e == null ? void 0 : e.prefix) !== false && t.push(...r4.prefix), r4.given && t.push(...r4.given), r4.family && t.push(r4.family), r4.suffix && (e == null ? void 0 : e.suffix) !== false && t.push(...r4.suffix), r4.use && ((e == null ? void 0 : e.all) || (e == null ? void 0 : e.use)) && t.push("[" + r4.use + "]"), t.length === 0) {
    let n = me(r4.text);
    if (n)
      return n;
  }
  return t.join(" ").trim();
}
function _c(r4) {
  let e = [];
  return r4.given && e.push(...r4.given), e.join(" ").trim();
}
function Uc(r4) {
  return me(r4.family) ?? "";
}
function ir(r4) {
  return r4 instanceof Date && !isNaN(r4.getTime());
}
function Lc(r4, e, t) {
  if (!r4)
    return "";
  let n = new Date(r4);
  return ir(n) ? (n.setUTCHours(0, 0, 0, 0), n.toLocaleDateString(e, { timeZone: "UTC", ...t })) : "";
}
function Qi(r4, e, t) {
  if (!r4)
    return "";
  let n = /* @__PURE__ */ new Date("2000-01-01T" + r4 + "Z");
  return ir(n) ? n.toLocaleTimeString(e, t) : "";
}
function nr(r4, e, t) {
  if (!r4)
    return "";
  let n = new Date(r4);
  return ir(n) ? n.toLocaleString(e, t) : "";
}
function Bc(r4, e, t) {
  return !r4 || !r4.start && !r4.end ? "" : nr(r4.start, e, t) + " - " + nr(r4.end, e, t);
}
var Hi = { s: "every second", min: "every minute", h: "hourly", d: "daily", wk: "weekly", mo: "monthly", a: "annually" };
var Wi = { s: "second", min: "minute", h: "hour", d: "day", wk: "week", mo: "month", a: "year" };
var Ki = { s: "seconds", min: "minutes", h: "hours", d: "days", wk: "weeks", mo: "months", a: "years" };
function qc(r4) {
  if (!r4)
    return "";
  let e = [];
  return zi(e, r4.repeat), r4.event && e.push(r4.event.map((t) => nr(t)).join(", ")), C(e.join(" ").trim());
}
function zi(r4, e) {
  if (!(e == null ? void 0 : e.periodUnit))
    return;
  let t = e.frequency ?? 1, n = e.period ?? 1, i = e.periodUnit;
  t === 1 && n === 1 ? r4.push(Hi[i]) : (t === 1 ? r4.push("once") : r4.push(t + " times"), n === 1 ? r4.push("per " + Wi[i]) : r4.push("per " + n + " " + Ki[i])), e.dayOfWeek && r4.push("on " + e.dayOfWeek.map(C).join(", ")), e.timeOfDay && r4.push("at " + e.timeOfDay.map((o) => Qi(o)).join(", "));
}
function jc(r4, e, t = false) {
  if (t && e === void 0)
    throw new Error("Precision must be specified for exclusive ranges");
  let n = (r4 == null ? void 0 : r4.low) && { ...r4.low, comparator: void 0 }, i = (r4 == null ? void 0 : r4.high) && { ...r4.high, comparator: void 0 };
  return (n == null ? void 0 : n.value) === void 0 && (i == null ? void 0 : i.value) === void 0 ? "" : (n == null ? void 0 : n.value) !== void 0 && (i == null ? void 0 : i.value) === void 0 ? t && e !== void 0 ? (n.value = eo(n.value, e), `> ${te(n, e)}`) : `>= ${te(n, e)}` : (n == null ? void 0 : n.value) === void 0 && (i == null ? void 0 : i.value) !== void 0 ? t && e !== void 0 ? (i.value = Xi(i.value, e), `< ${te(i, e)}`) : `<= ${te(i, e)}` : ((n == null ? void 0 : n.unit) === (i == null ? void 0 : i.unit) && (n == null ? true : delete n.unit), `${te(n, e)} - ${te(i, e)}`);
}
function te(r4, e) {
  if (!r4)
    return "";
  let t = [];
  return r4.comparator && (t.push(r4.comparator), t.push(" ")), r4.value !== void 0 && (e !== void 0 ? t.push(r4.value.toFixed(e)) : t.push(r4.value)), r4.unit && (r4.unit !== "%" && t[t.length - 1] !== " " && t.push(" "), t.push(r4.unit)), t.join("").trim();
}
function $c(r4) {
  return (r4 == null ? void 0 : r4.value) === void 0 ? "" : r4.value.toLocaleString(void 0, { style: "currency", currency: r4.currency ?? "USD", currencyDisplay: "narrowSymbol" });
}
function Ji(r4) {
  if (!r4)
    return "";
  let e = me(r4.text);
  return e || (r4.coding ? r4.coding.map((t) => Yi(t)).join(", ") : "");
}
function Yi(r4) {
  return me(r4 == null ? void 0 : r4.display) ?? me(r4 == null ? void 0 : r4.code) ?? "";
}
function Zi(r4) {
  if (!r4)
    return "";
  if ("component" in r4)
    return r4.component.map((t) => Zi(t)).join(" / ");
  if (r4.valueQuantity)
    return te(r4.valueQuantity);
  if (r4.valueCodeableConcept)
    return Ji(r4.valueCodeableConcept);
  let e = me(r4.valueString);
  return e || "";
}
function me(r4) {
  return typeof r4 == "string" ? r4 : void 0;
}
function Xi(r4, e, t = 1) {
  return (xn(r4, e) + t) * Math.pow(10, -e);
}
function eo(r4, e, t = 1) {
  return (xn(r4, e) - t) * Math.pow(10, -e);
}
function xn(r4, e) {
  return e === void 0 ? r4 : Math.round(r4 * Math.pow(10, e));
}
var l = { Address: "Address", Age: "Age", Annotation: "Annotation", Attachment: "Attachment", BackboneElement: "BackboneElement", CodeableConcept: "CodeableConcept", Coding: "Coding", ContactDetail: "ContactDetail", ContactPoint: "ContactPoint", Contributor: "Contributor", Count: "Count", DataRequirement: "DataRequirement", Distance: "Distance", Dosage: "Dosage", Duration: "Duration", Expression: "Expression", Extension: "Extension", HumanName: "HumanName", Identifier: "Identifier", MarketingStatus: "MarketingStatus", Meta: "Meta", Money: "Money", Narrative: "Narrative", ParameterDefinition: "ParameterDefinition", Period: "Period", Population: "Population", ProdCharacteristic: "ProdCharacteristic", ProductShelfLife: "ProductShelfLife", Quantity: "Quantity", Range: "Range", Ratio: "Ratio", Reference: "Reference", RelatedArtifact: "RelatedArtifact", SampledData: "SampledData", Signature: "Signature", SubstanceAmount: "SubstanceAmount", SystemString: "http://hl7.org/fhirpath/System.String", Timing: "Timing", TriggerDefinition: "TriggerDefinition", UsageContext: "UsageContext", base64Binary: "base64Binary", boolean: "boolean", canonical: "canonical", code: "code", date: "date", dateTime: "dateTime", decimal: "decimal", id: "id", instant: "instant", integer: "integer", markdown: "markdown", oid: "oid", positiveInt: "positiveInt", string: "string", time: "time", unsignedInt: "unsignedInt", uri: "uri", url: "url", uuid: "uuid" };
function Jc(r4) {
  for (let e of r4.entry) {
    let t = e.resource;
    t.resourceType === "SearchParameter" && or(t);
  }
}
function or(r4) {
  for (let e of r4.base ?? []) {
    let t = F.types[e];
    t || (t = { searchParamsDetails: {} }, F.types[e] = t), t.searchParams || (t.searchParams = { _id: { base: [e], code: "_id", type: "token", expression: e + ".id" }, _lastUpdated: { base: [e], code: "_lastUpdated", type: "date", expression: e + ".meta.lastUpdated" }, _compartment: { base: [e], code: "_compartment", type: "reference", expression: e + ".meta.compartment" }, _profile: { base: [e], code: "_profile", type: "uri", expression: e + ".meta.profile" }, _security: { base: [e], code: "_security", type: "token", expression: e + ".meta.security" }, _source: { base: [e], code: "_source", type: "uri", expression: e + ".meta.source" }, _tag: { base: [e], code: "_tag", type: "token", expression: e + ".meta.tag" } }), t.searchParams[r4.code] = r4;
  }
}
function Ut(r4) {
  var _a, _b, _c2, _d;
  let e = (_b = (_a = r4.type) == null ? void 0 : _a[0]) == null ? void 0 : _b.code;
  return e === "BackboneElement" || e === "Element" ? to((_d = ((_c2 = r4.base) == null ? void 0 : _c2.path) ?? r4.path) == null ? void 0 : _d.split(".")) : e;
}
function to(r4) {
  return r4.length === 1 ? r4[0] : r4.map(C).join("");
}
function Gt(r4) {
  return r4.kind === "resource" && r4.name !== "Resource" && r4.name !== "DomainResource";
}
function Yc() {
  return Object.values(Gr()).filter(Gt).map((r4) => r4.name);
}
function Zc(r4) {
  var _a;
  return (_a = F.types[r4]) == null ? void 0 : _a.searchParams;
}
function Xc(r4, e) {
  var _a, _b;
  return (_b = (_a = F.types[r4]) == null ? void 0 : _a.searchParams) == null ? void 0 : _b[e];
}
function eu(r4) {
  let e = r4.replaceAll("[x]", "").split(".").pop();
  return ro(e);
}
function ro(r4) {
  let e;
  return r4.length < 100 ? e = r4.match(/[A-Z]+(?![a-z])|[A-Z]?[a-z]+|\d+/g) ?? [] : e = r4.split(/(?=[A-Z])/), e.map(io).join(" ").replace("_", " ").replace(/\s+/g, " ");
}
var no = /* @__PURE__ */ new Set(["ID", "IP", "PKCE", "JWKS", "URI", "URL", "OMB", "UDI"]);
function io(r4) {
  let e = r4.toUpperCase();
  return r4 === e ? r4 : no.has(e) ? e : e.charAt(0) + r4.slice(1);
}
function ze(r4, e, t) {
  let n = be(r4, t);
  if (n)
    return oo(n.elements, e);
}
function oo(r4, e) {
  let t = r4[e] ?? r4[e + "[x]"];
  if (t)
    return t;
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (i >= "A" && i <= "Z") {
      let o = e.slice(0, n) + "[x]", s = r4[o];
      if (s)
        return s;
    }
  }
}
function _(r4) {
  return !!(r4 && typeof r4 == "object" && "resourceType" in r4);
}
function Y(r4) {
  return !!(r4 && typeof r4 == "object" && "reference" in r4 && typeof r4.reference == "string");
}
var F = { types: {} };
function Tn(r4) {
  var _a;
  switch (r4.type) {
    case l.uuid:
    case l.uri:
    case l.url:
    case l.string:
    case l.oid:
    case l.markdown:
    case l.id:
    case l.code:
    case l.canonical:
    case l.base64Binary:
    case l.SystemString:
    case l.date:
    case l.dateTime:
    case l.instant:
      return r4.value;
    case l.Identifier:
      return `${r4.value.system ?? ""}|${r4.value.value}`;
    case l.Coding:
      return vn(r4.value);
    case l.CodeableConcept:
      return ((_a = r4.value.coding) == null ? void 0 : _a.map(vn).join(",")) ?? r4.value.text;
    case l.HumanName:
      return r4.value.text ? r4.value.text : Ze(r4.value);
    case l.unsignedInt:
    case l.positiveInt:
    case l.integer:
    case l.decimal:
      return r4.value.toString();
    case l.boolean:
      return r4.value ? "true" : "false";
    case l.Extension:
      return r4.value.url;
    case l.ContactPoint:
      return r4.value.value;
    case l.Quantity:
    case l.Age:
    case l.Count:
    case l.Duration:
      return `${r4.value.value}|${r4.value.system ?? ""}|${r4.value.code ?? r4.value.unit ?? ""}`;
    case l.Reference:
      return r4.value.reference;
    default:
      return _(r4.value) ? Z(r4.value).reference : JSON.stringify(r4);
  }
}
function vn(r4) {
  return r4 ? `${r4.system ?? ""}|${r4.code}` : "";
}
function he(r4) {
  if (r4.startsWith("T"))
    return r4 + "T00:00:00.000Z".substring(r4.length);
  if (r4.length <= 10)
    return r4;
  try {
    return new Date(r4).toISOString();
  } catch {
    return r4;
  }
}
var Ce = () => [];
var w = { empty: (r4, e) => f(e.length === 0 || e.every((t) => S(t.value))), hasValue: (r4, e) => f(e.length !== 0), exists: (r4, e, t) => t ? f(e.filter((n) => N(t.eval(r4, [n]))).length > 0) : f(e.length > 0 && e.every((n) => !S(n.value))), all: (r4, e, t) => f(e.every((n) => N(t.eval(r4, [n])))), allTrue: (r4, e) => {
  for (let t of e)
    if (!t.value)
      return f(false);
  return f(true);
}, anyTrue: (r4, e) => {
  for (let t of e)
    if (t.value)
      return f(true);
  return f(false);
}, allFalse: (r4, e) => {
  for (let t of e)
    if (t.value)
      return f(false);
  return f(true);
}, anyFalse: (r4, e) => {
  for (let t of e)
    if (!t.value)
      return f(true);
  return f(false);
}, subsetOf: Ce, supersetOf: Ce, count: (r4, e) => [{ type: l.integer, value: e.length }], distinct: (r4, e) => {
  let t = [];
  for (let n of e)
    t.some((i) => i.value === n.value) || t.push(n);
  return t;
}, isDistinct: (r4, e) => f(e.length === w.distinct(r4, e).length), where: (r4, e, t) => e.filter((n) => N(t.eval(r4, [n]))), select: (r4, e, t) => e.map((n) => t.eval(r4, [n])).flat(), repeat: Ce, ofType: (r4, e, t) => e.filter((n) => n.type === t.name), single: (r4, e) => {
  if (e.length > 1)
    throw new Error("Expected input length one for single()");
  return e.length === 0 ? [] : e.slice(0, 1);
}, first: (r4, e) => e.length === 0 ? [] : e.slice(0, 1), last: (r4, e) => e.length === 0 ? [] : e.slice(e.length - 1, e.length), tail: (r4, e) => e.length === 0 ? [] : e.slice(1, e.length), skip: (r4, e, t) => {
  var _a;
  let n = (_a = t.eval(r4, e)[0]) == null ? void 0 : _a.value;
  if (typeof n != "number")
    throw new Error("Expected a number for skip(num)");
  return n >= e.length ? [] : n <= 0 ? e : e.slice(n, e.length);
}, take: (r4, e, t) => {
  var _a;
  let n = (_a = t.eval(r4, e)[0]) == null ? void 0 : _a.value;
  if (typeof n != "number")
    throw new Error("Expected a number for take(num)");
  return n >= e.length ? e : n <= 0 ? [] : e.slice(0, n);
}, intersect: (r4, e, t) => {
  if (!t)
    return e;
  let n = t.eval(r4, e), i = [];
  for (let o of e)
    !i.some((s) => s.value === o.value) && n.some((s) => s.value === o.value) && i.push(o);
  return i;
}, exclude: (r4, e, t) => {
  if (!t)
    return e;
  let n = t.eval(r4, e), i = [];
  for (let o of e)
    n.some((s) => s.value === o.value) || i.push(o);
  return i;
}, union: (r4, e, t) => {
  if (!t)
    return e;
  let n = t.eval(r4, e);
  return We([...e, ...n]);
}, combine: (r4, e, t) => {
  if (!t)
    return e;
  let n = t.eval(r4, e);
  return [...e, ...n];
}, htmlChecks: (r4, e, t) => [y(true)], iif: (r4, e, t, n, i) => {
  let o = t.eval(r4, e);
  if (o.length > 1 || o.length === 1 && typeof o[0].value != "boolean")
    throw new Error("Expected criterion to evaluate to a Boolean");
  return N(o) ? n.eval(r4, e) : i ? i.eval(r4, e) : [];
}, toBoolean: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  if (typeof t == "boolean")
    return [{ type: l.boolean, value: t }];
  if (typeof t == "number" && (t === 0 || t === 1))
    return f(!!t);
  if (typeof t == "string") {
    let n = t.toLowerCase();
    if (["true", "t", "yes", "y", "1", "1.0"].includes(n))
      return f(true);
    if (["false", "f", "no", "n", "0", "0.0"].includes(n))
      return f(false);
  }
  return [];
}, convertsToBoolean: (r4, e) => e.length === 0 ? [] : f(w.toBoolean(r4, e).length === 1), toInteger: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return typeof t == "number" ? [{ type: l.integer, value: t }] : typeof t == "string" && /^[+-]?\d+$/.exec(t) ? [{ type: l.integer, value: parseInt(t, 10) }] : typeof t == "boolean" ? [{ type: l.integer, value: t ? 1 : 0 }] : [];
}, convertsToInteger: (r4, e) => e.length === 0 ? [] : f(w.toInteger(r4, e).length === 1), toDate: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return typeof t == "string" && /^\d{4}(-\d{2}(-\d{2})?)?/.exec(t) ? [{ type: l.date, value: he(t) }] : [];
}, convertsToDate: (r4, e) => e.length === 0 ? [] : f(w.toDate(r4, e).length === 1), toDateTime: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return typeof t == "string" && /^\d{4}(-\d{2}(-\d{2})?)?/.exec(t) ? [{ type: l.dateTime, value: he(t) }] : [];
}, convertsToDateTime: (r4, e) => e.length === 0 ? [] : f(w.toDateTime(r4, e).length === 1), toDecimal: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return typeof t == "number" ? [{ type: l.decimal, value: t }] : typeof t == "string" && /^-?\d{1,9}(\.\d{1,9})?$/.exec(t) ? [{ type: l.decimal, value: parseFloat(t) }] : typeof t == "boolean" ? [{ type: l.decimal, value: t ? 1 : 0 }] : [];
}, convertsToDecimal: (r4, e) => e.length === 0 ? [] : f(w.toDecimal(r4, e).length === 1), toQuantity: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return A(t) ? [{ type: l.Quantity, value: t }] : typeof t == "number" ? [{ type: l.Quantity, value: { value: t, unit: "1" } }] : typeof t == "string" && /^-?\d{1,9}(\.\d{1,9})?/.exec(t) ? [{ type: l.Quantity, value: { value: parseFloat(t), unit: "1" } }] : typeof t == "boolean" ? [{ type: l.Quantity, value: { value: t ? 1 : 0, unit: "1" } }] : [];
}, convertsToQuantity: (r4, e) => e.length === 0 ? [] : f(w.toQuantity(r4, e).length === 1), toString: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  return t == null ? [] : A(t) ? [{ type: l.string, value: `${t.value} '${t.unit}'` }] : [{ type: l.string, value: t.toString() }];
}, convertsToString: (r4, e) => e.length === 0 ? [] : f(w.toString(r4, e).length === 1), toTime: (r4, e) => {
  if (e.length === 0)
    return [];
  let [{ value: t }] = q(e, 1);
  if (typeof t == "string") {
    let n = /^T?(\d{2}(:\d{2}(:\d{2})?)?)/.exec(t);
    if (n)
      return [{ type: l.time, value: he("T" + n[1]) }];
  }
  return [];
}, convertsToTime: (r4, e) => e.length === 0 ? [] : f(w.toTime(r4, e).length === 1), indexOf: (r4, e, t) => V((n, i) => n.indexOf(i), r4, e, t), substring: (r4, e, t, n) => V((i, o, s) => {
  let a = o, c = s ? a + s : i.length;
  return a < 0 || a >= i.length ? void 0 : i.substring(a, c);
}, r4, e, t, n), startsWith: (r4, e, t) => V((n, i) => n.startsWith(i), r4, e, t), endsWith: (r4, e, t) => V((n, i) => n.endsWith(i), r4, e, t), contains: (r4, e, t) => V((n, i) => n.includes(i), r4, e, t), upper: (r4, e) => V((t) => t.toUpperCase(), r4, e), lower: (r4, e) => V((t) => t.toLowerCase(), r4, e), replace: (r4, e, t, n) => V((i, o, s) => i.replaceAll(o, s), r4, e, t, n), matches: (r4, e, t) => V((n, i) => !!new RegExp(i).exec(n), r4, e, t), replaceMatches: (r4, e, t, n) => V((i, o, s) => i.replaceAll(o, s), r4, e, t, n), length: (r4, e) => V((t) => t.length, r4, e), toChars: (r4, e) => V((t) => t ? t.split("") : void 0, r4, e), abs: (r4, e) => B(Math.abs, r4, e), ceiling: (r4, e) => B(Math.ceil, r4, e), exp: (r4, e) => B(Math.exp, r4, e), floor: (r4, e) => B(Math.floor, r4, e), ln: (r4, e) => B(Math.log, r4, e), log: (r4, e, t) => B((n, i) => Math.log(n) / Math.log(i), r4, e, t), power: (r4, e, t) => B(Math.pow, r4, e, t), round: (r4, e) => B(Math.round, r4, e), sqrt: (r4, e) => B(Math.sqrt, r4, e), truncate: (r4, e) => B((t) => t | 0, r4, e), children: Ce, descendants: Ce, trace: (r4, e, t) => e, now: () => [{ type: l.dateTime, value: (/* @__PURE__ */ new Date()).toISOString() }], timeOfDay: () => [{ type: l.time, value: (/* @__PURE__ */ new Date()).toISOString().substring(11) }], today: () => [{ type: l.date, value: (/* @__PURE__ */ new Date()).toISOString().substring(0, 10) }], between: (r4, e, t, n, i) => {
  var _a;
  let o = w.toDateTime(r4, t.eval(r4, e));
  if (o.length === 0)
    throw new Error("Invalid start date");
  let s = w.toDateTime(r4, n.eval(r4, e));
  if (s.length === 0)
    throw new Error("Invalid end date");
  let a = (_a = i.eval(r4, e)[0]) == null ? void 0 : _a.value;
  if (a !== "years" && a !== "months" && a !== "days")
    throw new Error("Invalid units");
  let c = Ye(o[0].value, s[0].value);
  return [{ type: l.Quantity, value: { value: c[a], unit: a } }];
}, is: (r4, e, t) => {
  let n = "";
  return t instanceof j ? n = t.name : t instanceof W && (n = t.left.name + "." + t.right.name), n ? e.map((i) => ({ type: l.boolean, value: Ke(i, n) })) : [];
}, not: (r4, e) => w.toBoolean(r4, e).map((t) => ({ type: l.boolean, value: !t.value })), resolve: (r4, e) => e.map((t) => {
  let n = t.value, i;
  if (typeof n == "string")
    i = n;
  else if (typeof n == "object") {
    let o = n;
    if (o.resource)
      return y(o.resource);
    o.reference ? i = o.reference : o.type && o.identifier && (i = `${o.type}?identifier=${o.identifier.system}|${o.identifier.value}`);
  }
  if (i == null ? void 0 : i.includes("?")) {
    let [o] = i.split("?");
    return { type: o, value: { resourceType: o } };
  }
  if (i == null ? void 0 : i.includes("/")) {
    let [o, s] = i.split("/");
    return { type: o, value: { resourceType: o, id: s } };
  }
  return { type: l.BackboneElement, value: void 0 };
}).filter((t) => !!t.value), as: (r4, e) => e, type: (r4, e) => e.map(({ value: t }) => typeof t == "boolean" ? { type: l.BackboneElement, value: { namespace: "System", name: "Boolean" } } : typeof t == "number" ? { type: l.BackboneElement, value: { namespace: "System", name: "Integer" } } : _(t) ? { type: l.BackboneElement, value: { namespace: "FHIR", name: t.resourceType } } : { type: l.BackboneElement, value: null }), conformsTo: (r4, e, t) => {
  let n = t.eval(r4, e)[0].value;
  if (!n.startsWith("http://hl7.org/fhir/StructureDefinition/"))
    throw new Error("Expected a StructureDefinition URL");
  let i = n.replace("http://hl7.org/fhir/StructureDefinition/", "");
  return e.map((o) => {
    var _a;
    return { type: l.boolean, value: ((_a = o.value) == null ? void 0 : _a.resourceType) === i };
  });
} };
function V(r4, e, t, ...n) {
  if (t.length === 0)
    return [];
  let [{ value: i }] = q(t, 1);
  if (typeof i != "string")
    throw new Error("String function cannot be called with non-string");
  let o = r4(i, ...n.map((s) => {
    var _a;
    return (_a = s == null ? void 0 : s.eval(e, t)[0]) == null ? void 0 : _a.value;
  }));
  return o === void 0 ? [] : Array.isArray(o) ? o.map(y) : [y(o)];
}
function B(r4, e, t, ...n) {
  if (t.length === 0)
    return [];
  let [{ value: i }] = q(t, 1), o = A(i), s = o ? i.value : i;
  if (typeof s != "number")
    throw new Error("Math function cannot be called with non-number");
  let a = r4(s, ...n.map((p) => {
    var _a;
    return (_a = p.eval(e, t)[0]) == null ? void 0 : _a.value;
  })), c = o ? l.Quantity : t[0].type, u = o ? { ...i, value: a } : a;
  return [{ type: c, value: u }];
}
function q(r4, e) {
  if (r4.length !== e)
    throw new Error(`Expected ${e} arguments`);
  for (let t of r4)
    if (t == null)
      throw new Error("Expected non-null argument");
  return r4;
}
var Xe = class {
  constructor(e, t) {
    this.original = e;
    this.child = t;
  }
  eval(e, t) {
    try {
      return t.length > 0 ? t.map((n) => this.child.eval(e, [n])).flat() : this.child.eval(e, []);
    } catch (n) {
      throw new Error(`FhirPathError on "${this.original}": ${n}`);
    }
  }
  toString() {
    return this.child.toString();
  }
};
var D = class {
  constructor(e) {
    this.value = e;
  }
  eval() {
    return [this.value];
  }
  toString() {
    let e = this.value.value;
    return typeof e == "string" ? `'${e}'` : e.toString();
  }
};
var j = class {
  constructor(e) {
    this.name = e;
  }
  eval(e, t) {
    if (this.name === "$this")
      return t;
    let n = e.variables[this.name];
    if (n)
      return [n];
    if (this.name.startsWith("%"))
      throw new Error(`Undefined variable ${this.name}`);
    return t.flatMap((i) => this.evalValue(i)).filter((i) => (i == null ? void 0 : i.value) !== void 0);
  }
  evalValue(e) {
    let t = e.value;
    if (!(!t || typeof t != "object"))
      return _(t) && t.resourceType === this.name ? e : P(e, this.name);
  }
  toString() {
    return this.name;
  }
};
var et = class {
  eval() {
    return [];
  }
  toString() {
    return "{}";
  }
};
var tt = class extends Fe {
  constructor(t, n, i) {
    super(t, n);
    this.impl = i;
  }
  eval(t, n) {
    return this.impl(this.child.eval(t, n));
  }
  toString() {
    return this.operator + this.child.toString();
  }
};
var re = class extends H {
  constructor(e, t) {
    super("as", e, t);
  }
  eval(e, t) {
    return w.ofType(e, this.left.eval(e, t), this.right);
  }
};
var R = class extends H {
};
var I = class extends R {
  constructor(t, n, i, o) {
    super(t, n, i);
    this.impl = o;
  }
  eval(t, n) {
    let i = this.left.eval(t, n);
    if (i.length !== 1)
      return [];
    let o = this.right.eval(t, n);
    if (o.length !== 1)
      return [];
    let s = i[0].value, a = o[0].value, c = A(s) ? s.value : s, u = A(a) ? a.value : a, p = this.impl(c, u);
    return typeof p == "boolean" ? f(p) : A(s) ? [{ type: l.Quantity, value: { ...s, value: p } }] : [y(p)];
  }
};
var rt = class extends H {
  constructor(e, t) {
    super("&", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t), o = [...n, ...i];
    return o.length > 0 && o.every((s) => typeof s.value == "string") ? [{ type: l.string, value: o.map((s) => s.value).join("") }] : o;
  }
};
var nt = class extends R {
  constructor(e, t) {
    super("contains", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return f(n.some((o) => o.value === i[0].value));
  }
};
var it = class extends R {
  constructor(e, t) {
    super("in", e, t);
  }
  eval(e, t) {
    let n = U(this.left.eval(e, t)), i = this.right.eval(e, t);
    return n ? f(i.some((o) => o.value === n.value)) : [];
  }
};
var W = class extends H {
  constructor(e, t) {
    super(".", e, t);
  }
  eval(e, t) {
    return this.right.eval(e, this.left.eval(e, t));
  }
  toString() {
    return `${this.left.toString()}.${this.right.toString()}`;
  }
};
var ye = class extends H {
  constructor(e, t) {
    super("|", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return We([...n, ...i]);
  }
};
var ot = class extends R {
  constructor(e, t) {
    super("=", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return Yt(n, i);
  }
};
var st = class extends R {
  constructor(e, t) {
    super("!=", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return Jt(Yt(n, i));
  }
};
var at = class extends R {
  constructor(e, t) {
    super("~", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return Zt(n, i);
  }
};
var ct = class extends R {
  constructor(e, t) {
    super("!~", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t), i = this.right.eval(e, t);
    return Jt(Zt(n, i));
  }
};
var ne = class extends R {
  constructor(e, t) {
    super("is", e, t);
  }
  eval(e, t) {
    let n = this.left.eval(e, t);
    if (n.length !== 1)
      return [];
    let i = this.right.name;
    return f(Ke(n[0], i));
  }
};
var ut = class extends R {
  constructor(e, t) {
    super("and", e, t);
  }
  eval(e, t) {
    let n = U(this.left.eval(e, t), "boolean"), i = U(this.right.eval(e, t), "boolean");
    return (n == null ? void 0 : n.value) === true && (i == null ? void 0 : i.value) === true ? f(true) : (n == null ? void 0 : n.value) === false || (i == null ? void 0 : i.value) === false ? f(false) : [];
  }
};
var lt = class extends R {
  constructor(e, t) {
    super("or", e, t);
  }
  eval(e, t) {
    let n = U(this.left.eval(e, t), "boolean"), i = U(this.right.eval(e, t), "boolean");
    return (n == null ? void 0 : n.value) === false && (i == null ? void 0 : i.value) === false ? f(false) : (n == null ? void 0 : n.value) || (i == null ? void 0 : i.value) ? f(true) : [];
  }
};
var pt = class extends R {
  constructor(e, t) {
    super("xor", e, t);
  }
  eval(e, t) {
    let n = U(this.left.eval(e, t), "boolean"), i = U(this.right.eval(e, t), "boolean");
    return !n || !i ? [] : f(n.value !== i.value);
  }
};
var dt = class extends R {
  constructor(e, t) {
    super("implies", e, t);
  }
  eval(e, t) {
    let n = U(this.left.eval(e, t), "boolean"), i = U(this.right.eval(e, t), "boolean");
    return (i == null ? void 0 : i.value) === true || (n == null ? void 0 : n.value) === false ? f(true) : !n || !i ? [] : f(false);
  }
};
var Q = class {
  constructor(e, t) {
    this.name = e;
    this.args = t;
  }
  eval(e, t) {
    let n = w[this.name];
    if (!n)
      throw new Error("Unrecognized function: " + this.name);
    return n(e, t, ...this.args);
  }
  toString() {
    return `${this.name}(${this.args.map((e) => e.toString()).join(", ")})`;
  }
};
var ie = class {
  constructor(e, t) {
    this.left = e;
    this.expr = t;
  }
  eval(e, t) {
    let n = this.expr.eval(e, t);
    if (n.length !== 1)
      return [];
    let i = n[0].value;
    if (typeof i != "number")
      throw new Error("Invalid indexer expression: should return integer}");
    let o = this.left.eval(e, t);
    return i in o ? [o[i]] : [];
  }
  toString() {
    return `${this.left.toString()}[${this.expr.toString()}]`;
  }
};
var so = ["year", "years", "month", "months", "week", "weeks", "day", "days", "hour", "hours", "minute", "minutes", "second", "seconds", "millisecond", "milliseconds"];
var K = class {
  constructor(e, t, n, i) {
    this.result = [];
    this.pos = { index: 0, line: 1, column: 0 };
    this.markStack = [];
    this.str = e, this.keywords = t, this.operators = n, this.dateTimeLiterals = !!(i == null ? void 0 : i.dateTimeLiterals), this.symbolRegex = (i == null ? void 0 : i.symbolRegex) ?? /[$\w%]/;
  }
  tokenize() {
    for (; this.pos.index < this.str.length; ) {
      let e = this.consumeToken();
      e && this.result.push(e);
    }
    return this.result;
  }
  prevToken() {
    return this.result.slice(-1)[0];
  }
  peekToken() {
    this.mark();
    let e = this.consumeToken();
    return this.reset(), e;
  }
  consumeToken() {
    this.consumeWhitespace();
    let e = this.curr();
    if (!e)
      return;
    this.mark();
    let t = this.peek();
    return e === "/" && t === "*" ? this.consumeMultiLineComment() : e === "/" && t === "/" ? this.consumeSingleLineComment() : e === "'" || e === '"' ? this.consumeString(e) : e === "`" ? this.consumeBacktickSymbol() : e === "@" ? this.consumeDateTime() : /\d/.exec(e) ? this.consumeNumber() : /\w/.exec(e) ? this.consumeSymbol() : (e === "$" || e === "%") && /\w/.exec(t) ? this.consumeSymbol() : this.consumeOperator();
  }
  consumeWhitespace() {
    this.consumeWhile(() => /\s/.exec(this.curr()));
  }
  consumeMultiLineComment() {
    let e = this.pos.index;
    return this.consumeWhile(() => this.curr() !== "*" || this.peek() !== "/"), this.advance(), this.advance(), this.buildToken("Comment", this.str.substring(e, this.pos.index));
  }
  consumeSingleLineComment() {
    return this.buildToken("Comment", this.consumeWhile(() => this.curr() !== `
`));
  }
  consumeString(e) {
    this.advance();
    let t = this.buildToken("String", this.consumeWhile(() => this.prev() === "\\" || this.curr() !== e));
    return this.advance(), t;
  }
  consumeBacktickSymbol() {
    this.advance();
    let e = this.buildToken("Symbol", this.consumeWhile(() => this.curr() !== "`"));
    return this.advance(), e;
  }
  consumeDateTime() {
    this.advance();
    let e = this.pos.index;
    this.consumeWhile(() => /[\d-]/.exec(this.curr()));
    let t = false, n = false;
    this.curr() === "T" && (t = true, this.advance(), this.consumeWhile(() => /[\d:]/.exec(this.curr())), this.curr() === "." && /\d/.exec(this.peek()) && (this.advance(), this.consumeWhile(() => /\d/.exec(this.curr()))), this.curr() === "Z" ? (n = true, this.advance()) : (this.curr() === "+" || this.curr() === "-") && (n = true, this.advance(), this.consumeWhile(() => /[\d:]/.exec(this.curr()))));
    let i = this.str.substring(e, this.pos.index);
    return i.endsWith("T") ? i = i.substring(0, i.length - 1) : !i.startsWith("T") && t && !n && (i += "Z"), this.buildToken("DateTime", i);
  }
  consumeNumber() {
    let e = this.pos.index, t = "Number";
    return this.consumeWhile(() => /\d/.exec(this.curr())), this.curr() === "." && /\d/.exec(this.peek()) && (this.advance(), this.consumeWhile(() => /\d/.exec(this.curr()))), this.curr() === "-" && this.dateTimeLiterals ? (this.pos.index = e - 1, this.consumeDateTime()) : (this.curr() === " " && ao(this.peekToken()) && (t = "Quantity", this.consumeToken()), this.buildToken(t, this.str.substring(e, this.pos.index)));
  }
  consumeSymbol() {
    var _a;
    let e = this.consumeWhile(() => this.symbolRegex.exec(this.curr()));
    return ((_a = this.prevToken()) == null ? void 0 : _a.value) !== "." && this.keywords.includes(e) ? this.buildToken(e, e) : this.buildToken("Symbol", e);
  }
  consumeOperator() {
    let e = this.curr(), t = this.peek(), n = e + t;
    return this.operators.includes(n) ? (this.advance(), this.advance(), this.buildToken(n, n)) : (this.advance(), this.buildToken(e, e));
  }
  consumeWhile(e) {
    let t = this.pos.index;
    for (; this.pos.index < this.str.length && e(); )
      this.advance();
    return this.str.substring(t, this.pos.index);
  }
  curr() {
    return this.str[this.pos.index];
  }
  prev() {
    return this.str[this.pos.index - 1] ?? "";
  }
  peek() {
    return this.str[this.pos.index + 1] ?? "";
  }
  mark() {
    this.markStack.push({ ...this.pos });
  }
  reset() {
    let e = this.markStack.pop();
    if (!e)
      throw new Error("No mark to reset to");
    this.pos.index = e.index, this.pos.line = e.line, this.pos.column = e.column;
  }
  advance() {
    this.pos.index++, this.curr() === `
` ? (this.pos.line++, this.pos.column = 0) : this.pos.column++;
  }
  buildToken(e, t) {
    let n = this.markStack.pop();
    if (!n)
      throw new Error("No mark for token");
    return { id: e, value: t, ...n };
  }
};
function ao(r4) {
  return !!(r4 && (r4.id === "String" || r4.id === "Symbol" && so.includes(r4.value)));
}
var Pe = ["true", "false"];
var we = ["!=", "!~", "<=", ">=", "{}", "->"];
function Sn(r4) {
  return new K(r4, Pe, we).tokenize();
}
var h = { FunctionCall: 0, Dot: 1, Indexer: 2, UnaryAdd: 3, UnarySubtract: 3, Multiply: 4, Divide: 4, IntegerDivide: 4, Modulo: 4, Add: 5, Subtract: 5, Ampersand: 5, Is: 6, As: 6, Union: 7, GreaterThan: 8, GreaterThanOrEquals: 8, LessThan: 8, LessThanOrEquals: 8, Equals: 9, Equivalent: 9, NotEquals: 9, NotEquivalent: 9, In: 10, Contains: 10, And: 11, Xor: 12, Or: 12, Implies: 13, Arrow: 100, Semicolon: 200 };
var co = { parse(r4) {
  var _a;
  let e = r4.consumeAndParse();
  if (!r4.match(")"))
    throw new Error("Parse error: expected `)` got `" + ((_a = r4.peek()) == null ? void 0 : _a.value) + "`");
  return e;
} };
var uo = { parse(r4, e) {
  let t = r4.consumeAndParse();
  if (!r4.match("]"))
    throw new Error("Parse error: expected `]`");
  return new ie(e, t);
}, precedence: h.Indexer };
var lo = { parse(r4, e) {
  if (!(e instanceof j))
    throw new Error("Unexpected parentheses");
  let t = [];
  for (; !r4.match(")"); )
    t.push(r4.consumeAndParse()), r4.match(",");
  return new Q(e.name, t);
}, precedence: h.FunctionCall };
function po(r4) {
  let e = r4.split(" "), t = parseFloat(e[0]), n = e[1];
  return (n == null ? void 0 : n.startsWith("'")) && n.endsWith("'") ? n = n.substring(1, n.length - 1) : n = "{" + n + "}", { value: t, unit: n };
}
function Ae() {
  return new _e().registerPrefix("String", { parse: (r4, e) => new D({ type: l.string, value: e.value }) }).registerPrefix("DateTime", { parse: (r4, e) => new D({ type: l.dateTime, value: he(e.value) }) }).registerPrefix("Quantity", { parse: (r4, e) => new D({ type: l.Quantity, value: po(e.value) }) }).registerPrefix("Number", { parse: (r4, e) => new D({ type: e.value.includes(".") ? l.decimal : l.integer, value: parseFloat(e.value) }) }).registerPrefix("true", { parse: () => new D({ type: l.boolean, value: true }) }).registerPrefix("false", { parse: () => new D({ type: l.boolean, value: false }) }).registerPrefix("Symbol", { parse: (r4, e) => new j(e.value) }).registerPrefix("{}", { parse: () => new et() }).registerPrefix("(", co).registerInfix("[", uo).registerInfix("(", lo).prefix("+", h.UnaryAdd, (r4, e) => new tt("+", e, (t) => t)).prefix("-", h.UnarySubtract, (r4, e) => new I("-", e, e, (t, n) => -n)).infixLeft(".", h.Dot, (r4, e, t) => new W(r4, t)).infixLeft("/", h.Divide, (r4, e, t) => new I("/", r4, t, (n, i) => n / i)).infixLeft("*", h.Multiply, (r4, e, t) => new I("*", r4, t, (n, i) => n * i)).infixLeft("+", h.Add, (r4, e, t) => new I("+", r4, t, (n, i) => n + i)).infixLeft("-", h.Subtract, (r4, e, t) => new I("-", r4, t, (n, i) => n - i)).infixLeft("|", h.Union, (r4, e, t) => new ye(r4, t)).infixLeft("=", h.Equals, (r4, e, t) => new ot(r4, t)).infixLeft("!=", h.NotEquals, (r4, e, t) => new st(r4, t)).infixLeft("~", h.Equivalent, (r4, e, t) => new at(r4, t)).infixLeft("!~", h.NotEquivalent, (r4, e, t) => new ct(r4, t)).infixLeft("<", h.LessThan, (r4, e, t) => new I("<", r4, t, (n, i) => n < i)).infixLeft("<=", h.LessThanOrEquals, (r4, e, t) => new I("<=", r4, t, (n, i) => n <= i)).infixLeft(">", h.GreaterThan, (r4, e, t) => new I(">", r4, t, (n, i) => n > i)).infixLeft(">=", h.GreaterThanOrEquals, (r4, e, t) => new I(">=", r4, t, (n, i) => n >= i)).infixLeft("&", h.Ampersand, (r4, e, t) => new rt(r4, t)).infixLeft("and", h.And, (r4, e, t) => new ut(r4, t)).infixLeft("as", h.As, (r4, e, t) => new re(r4, t)).infixLeft("contains", h.Contains, (r4, e, t) => new nt(r4, t)).infixLeft("div", h.Divide, (r4, e, t) => new I("div", r4, t, (n, i) => n / i | 0)).infixLeft("in", h.In, (r4, e, t) => new it(r4, t)).infixLeft("is", h.Is, (r4, e, t) => new ne(r4, t)).infixLeft("mod", h.Modulo, (r4, e, t) => new I("mod", r4, t, (n, i) => n % i)).infixLeft("or", h.Or, (r4, e, t) => new lt(r4, t)).infixLeft("xor", h.Xor, (r4, e, t) => new pt(r4, t)).infixLeft("implies", h.Implies, (r4, e, t) => new dt(r4, t));
}
var fo = Ae();
function sr(r4) {
  return new Xe(r4, fo.construct(Sn(r4)).consumeAndParse());
}
function ge(r4, e) {
  let t = Array.isArray(e) ? e : [e];
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    typeof i == "object" && "type" in i && "value" in i || (t[n] = y(t[n]));
  }
  return $(r4, t).map((n) => n.value);
}
function $(r4, e, t) {
  let n = t ?? {};
  return sr(r4).eval({ variables: n }, e).map((o) => {
    var _a;
    return { type: o.type, value: (_a = o.value) == null ? void 0 : _a.valueOf() };
  });
}
var En = ((p) => (p.BOOLEAN = "BOOLEAN", p.NUMBER = "NUMBER", p.QUANTITY = "QUANTITY", p.TEXT = "TEXT", p.REFERENCE = "REFERENCE", p.CANONICAL = "CANONICAL", p.DATE = "DATE", p.DATETIME = "DATETIME", p.PERIOD = "PERIOD", p.UUID = "UUID", p))(En || {});
function bn(r4, e) {
  var _a, _b;
  let t = (_b = (_a = F.types[r4]) == null ? void 0 : _a.searchParamsDetails) == null ? void 0 : _b[e.code];
  return t || (t = ho(r4, e)), t;
}
function mo(r4, e, t) {
  let n = F.types[r4];
  n.searchParamsDetails || (n.searchParamsDetails = {}), n.searchParamsDetails[e] = t;
}
function ho(r4, e) {
  let t = e.code, n = xo(t), i = Cn(r4, e.expression), o = { elementDefinitions: [], propertyTypes: /* @__PURE__ */ new Set(), array: false };
  for (let a of i) {
    let c = Ie(a);
    c.length === 1 && c[0] instanceof R ? o.propertyTypes.add("boolean") : Rn(o, Ie(a), r4, 1);
  }
  let s = { columnName: n, type: vo(e, o.propertyTypes), elementDefinitions: o.elementDefinitions, array: o.array };
  return mo(r4, t, s), s;
}
function Rn(r4, e, t, n) {
  let i = e[n];
  if (i instanceof re) {
    r4.propertyTypes.add(i.right.toString());
    return;
  }
  if (i instanceof Q) {
    yo(r4, i);
    return;
  }
  let o = i.toString(), s = ze(t, o);
  if (!s)
    throw new Error(`Element definition not found for ${t} ${o}`);
  let a = false, c = n + 1;
  if (c < e.length && e[c] instanceof ie && (a = true, c++), s.isArray && !a && (r4.array = true), c >= e.length) {
    r4.elementDefinitions.push(s);
    for (let u of s.type)
      r4.propertyTypes.add(u.code);
    return;
  }
  for (let u of s.type) {
    let p = u.code;
    go(p) && (p = s.type[0].code), Rn(r4, e, p, c);
  }
}
function yo(r4, e) {
  if (e.name === "as") {
    r4.propertyTypes.add(e.args[0].toString());
    return;
  }
  if (e.name === "resolve") {
    r4.propertyTypes.add("string");
    return;
  }
  if (e.name === "where" && e.args[0] instanceof ne) {
    r4.propertyTypes.add(e.args[0].right.toString());
    return;
  }
  throw new Error(`Unhandled FHIRPath function: ${e.name}`);
}
function go(r4) {
  return r4 === "Element" || r4 === "BackboneElement";
}
function xo(r4) {
  return r4.split("-").reduce((e, t, n) => e + (n ? C(t) : t), "");
}
function vo(r4, e) {
  switch (r4.type) {
    case "date":
      return e.size === 1 && e.has(l.date) ? "DATE" : "DATETIME";
    case "number":
      return "NUMBER";
    case "quantity":
      return "QUANTITY";
    case "reference":
      return e.has(l.canonical) ? "CANONICAL" : "REFERENCE";
    case "token":
      return e.size === 1 && e.has(l.boolean) ? "BOOLEAN" : "TEXT";
    default:
      return "TEXT";
  }
}
function Cn(r4, e) {
  let t = [], n = sr(e);
  return ar(r4, n.child, t), t;
}
function Uu(r4, e) {
  let t = Cn(r4, e);
  if (t.length !== 0)
    return t.map((n) => n.toString()).join(" | ");
}
function ar(r4, e, t) {
  e instanceof ye ? (ar(r4, e.left, t), ar(r4, e.right, t)) : e.toString().startsWith(r4 + ".") && t.push(e);
}
function Ie(r4) {
  if (r4 instanceof re || r4 instanceof ie)
    return [Ie(r4.left), r4].flat();
  if (r4 instanceof R)
    return [r4];
  if (r4 instanceof W)
    return [Ie(r4.left), Ie(r4.right)].flat();
  if (r4 instanceof Q) {
    if (r4.name === "where" && !(r4.args[0] instanceof ne))
      return [];
    if (r4.name === "last")
      return [];
  }
  return [r4];
}
var Qu = 20;
var To = ((T) => (T.EQUALS = "eq", T.NOT_EQUALS = "ne", T.GREATER_THAN = "gt", T.LESS_THAN = "lt", T.GREATER_THAN_OR_EQUALS = "ge", T.LESS_THAN_OR_EQUALS = "le", T.STARTS_AFTER = "sa", T.ENDS_BEFORE = "eb", T.APPROXIMATELY = "ap", T.CONTAINS = "contains", T.EXACT = "exact", T.TEXT = "text", T.NOT = "not", T.ABOVE = "above", T.BELOW = "below", T.IN = "in", T.NOT_IN = "not-in", T.OF_TYPE = "of-type", T.MISSING = "missing", T.IDENTIFIER = "identifier", T.ITERATE = "iterate", T))(To || {});
var An = { contains: "contains", exact: "exact", above: "above", below: "below", text: "text", not: "not", in: "in", "not-in": "not-in", "of-type": "of-type", missing: "missing", identifier: "identifier", iterate: "iterate" };
var cr = { eq: "eq", ne: "ne", lt: "lt", le: "le", gt: "gt", ge: "ge", sa: "sa", eb: "eb", ap: "ap" };
function xe(r4, e) {
  if (!r4)
    throw new Error("Invalid search URL");
  let t = "", n;
  if (typeof r4 == "string")
    if (r4.includes("?")) {
      let [s, a] = r4.split("?");
      t = s, n = new URLSearchParams(a);
    } else
      t = r4;
  else
    typeof r4 == "object" && (t = r4.pathname, n = r4.searchParams);
  let i;
  t.includes("/") ? i = t.split("/").filter(Boolean).pop() : i = t;
  let o = [];
  if (n && o.push(...n.entries()), e)
    for (let [s, a] of Object.entries(e))
      if (Array.isArray(a))
        for (let c of a)
          o.push([s, c]);
      else
        o.push([s, a ?? ""]);
  return So(i, o);
}
function Hu(r4) {
  return xe(r4);
}
function Wu(r4) {
  return xe(r4);
}
function Ku(r4) {
  return xe(r4);
}
function So(r4, e) {
  let t = { resourceType: r4 };
  for (let [n, i] of e)
    Eo(t, n, i);
  return t;
}
function Eo(r4, e, t) {
  var _a, _b;
  let n, i, o = e.indexOf(":");
  if (o >= 0 ? (n = e.substring(0, o), i = e.substring(o + 1)) : (n = e, i = ""), n !== "_") {
    if (n === "_has" || e.includes(".")) {
      r4.filters = fe(r4.filters, { code: e, operator: "eq", value: t });
      return;
    }
    switch (n) {
      case "_sort":
        bo(r4, t);
        break;
      case "_count":
        r4.count = parseInt(t, 10);
        break;
      case "_offset":
        r4.offset = parseInt(t, 10);
        break;
      case "_total":
        r4.total = t;
        break;
      case "_summary":
        t === "count" ? (r4.total = "accurate", r4.count = 0) : (t === "true" || t === "data" || t === "text") && (r4.summary = t);
        break;
      case "_include": {
        let s = Pn(t);
        i === "iterate" && (s.modifier = "iterate"), r4.include = fe(r4.include, s);
        break;
      }
      case "_revinclude": {
        let s = Pn(t);
        i === "iterate" && (s.modifier = "iterate"), r4.revInclude = fe(r4.revInclude, s);
        break;
      }
      case "_fields":
      case "_elements":
        r4.fields = t.split(",");
        break;
      case "_type":
        r4.types = t.split(",");
        break;
      case "_format":
        r4.format = t;
        break;
      case "_pretty":
        r4.pretty = t === "true";
        break;
      default: {
        let s = (_b = (_a = F.types[r4.resourceType]) == null ? void 0 : _a.searchParams) == null ? void 0 : _b[n];
        s ? r4.filters = fe(r4.filters, Ro(s, i, t)) : r4.filters = fe(r4.filters, wo(n, i, t));
      }
    }
  }
}
function bo(r4, e) {
  for (let t of e.split(",")) {
    let n, i = false;
    t.startsWith("-") ? (n = t.substring(1), i = true) : n = t, r4.sortRules || (r4.sortRules = []), r4.sortRules.push({ code: n, descending: i });
  }
}
function Ro(r4, e, t) {
  if (e === "missing")
    return { code: r4.code, operator: "missing", value: t };
  switch (r4.type) {
    case "number":
    case "date":
    case "quantity":
      return Co(r4, t);
    case "reference":
    case "string":
    case "token":
    case "uri":
      return Po(r4, e, t);
    default:
      throw new Error("Unrecognized search parameter type: " + r4.type);
  }
}
function Co(r4, e) {
  let { operator: t, value: n } = Ao(e);
  return { code: r4.code, operator: t, value: n };
}
function Po(r4, e, t) {
  return { code: r4.code, operator: Io(e), value: t };
}
function wo(r4, e, t) {
  var _a;
  let n = "eq";
  if (e)
    n = e;
  else if (t.length >= 2) {
    let i = t.substring(0, 2);
    i in cr && (t.length === 2 || ((_a = t.at(2)) == null ? void 0 : _a.match(/\d/))) && (n = i, t = t.substring(i.length));
  }
  return { code: r4, operator: n, value: t };
}
function Ao(r4) {
  let e = r4.substring(0, 2), t = cr[e];
  return t ? { operator: t, value: r4.substring(2) } : { operator: "eq", value: r4 };
}
function Io(r4) {
  return An[r4] ?? "eq";
}
function Pn(r4) {
  let e = r4.split(":");
  if (e.includes("*"))
    throw new d(b("'*' is not supported as a value for search inclusion parameters"));
  if (e.length === 1)
    throw new d(b(`Invalid include value '${r4}': must be of the form ResourceType:search-parameter`));
  if (e.length === 2)
    return { resourceType: e[0], searchParam: e[1] };
  if (e.length === 3)
    return { resourceType: e[0], searchParam: e[1], targetType: e[2] };
  throw new d(b(`Invalid include value '${r4}'`));
}
var ko = /{{([^{}]+)}}/g;
function zu(r4, e) {
  return r4 = r4.replaceAll(ko, (t, n) => {
    let i = $(n, [], e);
    return i.length !== 1 ? "" : Tn(i[0]);
  }), xe(r4);
}
function Ju(r4) {
  let e = [];
  return r4.fields && e.push("_fields=" + r4.fields.join(",")), r4.filters && r4.filters.forEach((t) => e.push(Oo(t))), r4.sortRules && r4.sortRules.length > 0 && e.push(Vo(r4.sortRules)), r4.offset !== void 0 && e.push("_offset=" + r4.offset), r4.count !== void 0 && e.push("_count=" + r4.count), r4.total !== void 0 && e.push("_total=" + r4.total), r4.include && r4.include.forEach((t) => e.push(wn("_include", t))), r4.revInclude && r4.revInclude.forEach((t) => e.push(wn("_revinclude", t))), e.length === 0 ? "" : (e.sort((t, n) => t.localeCompare(n)), "?" + e.join("&"));
}
function Oo(r4) {
  let e = r4.operator in An ? ":" + r4.operator : "", t = r4.operator !== "eq" && r4.operator in cr ? r4.operator : "";
  return `${r4.code}${e}=${t}${encodeURIComponent(r4.value)}`;
}
function Vo(r4) {
  return "_sort=" + r4.map((e) => e.descending ? "-" + e.code : e.code).join(",");
}
function wn(r4, e) {
  return r4 + "=" + e.resourceType + ":" + e.searchParam + (e.targetType ? ":" + e.targetType : "");
}
function In(r4, e) {
  if (e.resourceType !== r4.resourceType)
    return false;
  if (e.filters) {
    for (let t of e.filters)
      if (!Do(r4, e, t))
        return false;
  }
  return true;
}
function Do(r4, e, t) {
  var _a, _b;
  let n = (_b = (_a = F.types[e.resourceType]) == null ? void 0 : _a.searchParams) == null ? void 0 : _b[t.code];
  if (t.operator === "missing" && n) {
    let i = ge(n.expression, r4);
    return t.value === "true" ? !i.length : i.length > 0;
  }
  switch (n == null ? void 0 : n.type) {
    case "reference":
      return Mo(r4, t, n);
    case "string":
    case "uri":
      return kn(r4, t, n);
    case "token":
      return No(r4, t, n);
    case "date":
      return _o(r4, t, n);
    default:
      return false;
  }
}
function Mo(r4, e, t) {
  let n = ge(t.expression, r4), i = ft(e.operator);
  if (e.value === "" && n.length === 0)
    return e.operator === "eq";
  let o = n.map((s) => typeof s == "string" ? s : s.reference);
  for (let s of e.value.split(",")) {
    let a = o.includes(s);
    if (!a && e.code === "_compartment" && (a = o.some((c) => c == null ? void 0 : c.endsWith("/" + s))), a)
      return !i;
  }
  return i;
}
function No(r4, e, t) {
  return bn(r4.resourceType, t).type === "BOOLEAN" ? Fo(r4, e, t) : kn(r4, e, t, true);
}
function Fo(r4, e, t) {
  let n = ge(t.expression, r4), i = e.value === "true", o = n.includes(i);
  return ft(e.operator) ? !o : o;
}
function kn(r4, e, t, n) {
  let i = ge(t.expression, r4), o = e.value.split(","), s = ft(e.operator);
  for (let a of i)
    for (let c of o)
      if (ur(a, e.operator, c, n))
        return !s;
  return s;
}
function ur(r4, e, t, n) {
  if (n && t.includes("|")) {
    let [o, s] = t.split("|");
    return ur(r4, e, o, false) && (!s || ur(r4, e, s, false));
  }
  let i = "";
  return r4 && (typeof r4 == "string" ? i = r4 : typeof r4 == "object" && (i = JSON.stringify(r4))), i.toLowerCase().includes(t.toLowerCase());
}
function _o(r4, e, t) {
  let n = ge(t.expression, r4), i = e.value.split(","), o = ft(e.operator);
  for (let s of n)
    for (let a of i)
      if (Uo(s, e.operator, a))
        return !o;
  return o;
}
function Uo(r4, e, t) {
  switch (e) {
    case "sa":
    case "gt":
      return r4 > t;
    case "ge":
      return r4 >= t;
    case "eb":
    case "lt":
      return r4 < t;
    case "le":
      return r4 <= t;
    case "eq":
    case "ne":
      return r4 === t;
    default:
      return false;
  }
}
function ft(r4) {
  return r4 === "ne" || r4 === "not";
}
var Lo = { resourceType: "*" };
var Bo = ["DomainConfiguration", "JsonWebKey", "Login"];
var qo = ["PasswordChangeRequest", "Project", "ProjectMembership", "User"];
var jo = ((E) => (E.READ = "read", E.VREAD = "vread", E.UPDATE = "update", E.PATCH = "patch", E.DELETE = "delete", E.HISTORY = "history", E.HISTORY_INSTANCE = "history-instance", E.HISTORY_TYPE = "history-type", E.HISTORY_SYSTEM = "history-system", E.CREATE = "create", E.SEARCH = "search", E.SEARCH_TYPE = "search-type", E.SEARCH_SYSTEM = "search-system", E.SEARCH_COMPARTMENT = "search-compartment", E.CAPABILITIES = "capabilities", E.TRANSACTION = "transaction", E.BATCH = "batch", E.OPERATION = "operation", E))(jo || {});
var $o = ["read", "vread", "history", "history-instance"];
function il(r4, e) {
  if (r4.resource) {
    for (let t of r4.resource)
      if (lr(t.resourceType, e))
        return true;
  }
  return false;
}
function Go(r4, e) {
  if (Bo.includes(e))
    return false;
  if (r4.resource) {
    for (let t of r4.resource)
      if (lr(t.resourceType, e) && !t.readonly)
        return true;
  }
  return false;
}
function ol(r4, e) {
  let t = e.resourceType;
  return Go(r4, t) ? Qo(r4, e, false) : false;
}
function Qo(r4, e, t) {
  if (r4.resource) {
    for (let n of r4.resource)
      if (On(e, t ? "read" : "update", n))
        return true;
  }
  return false;
}
function sl(r4, e, t) {
  if (!t)
    return Lo;
  if (t.resource) {
    for (let n of t.resource)
      if (On(r4, e, n))
        return n;
  }
}
function On(r4, e, t) {
  var _a, _b;
  let n = r4.resourceType;
  return !(!lr(t.resourceType, n) || t.readonly && !$o.includes(e) || t.compartment && !((_b = (_a = r4.meta) == null ? void 0 : _a.compartment) == null ? void 0 : _b.find((i) => {
    var _a2;
    return i.reference === ((_a2 = t.compartment) == null ? void 0 : _a2.reference);
  })) || t.criteria && !In(r4, xe(t.criteria)));
}
function lr(r4, e) {
  return r4 === e || r4 === "*" && !qo.includes(e);
}
function Vn(r4) {
  if (typeof window < "u")
    return window.atob(r4);
  if (typeof Buffer < "u")
    return Buffer.from(r4, "base64").toString("binary");
  throw new Error("Unable to decode base64");
}
function Dn(r4) {
  if (typeof window < "u")
    return window.btoa(r4);
  if (typeof Buffer < "u")
    return Buffer.from(r4, "binary").toString("base64");
  throw new Error("Unable to encode base64");
}
function pr() {
  let r4 = new Uint32Array(28);
  return crypto.getRandomValues(r4), fn(r4.buffer);
}
async function Mn(r4) {
  return crypto.subtle.digest("SHA-256", new TextEncoder().encode(r4));
}
function oe() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r4) => {
    let e = Math.random() * 16 | 0;
    return (r4 === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ho(r4) {
  var _a, _b, _c2;
  let e = {};
  r4 = ee(r4);
  for (let i of r4.entry || []) {
    ((_a = i.resource) == null ? void 0 : _a.meta) !== void 0 && (delete i.resource.meta.author, delete i.resource.meta.compartment, delete i.resource.meta.lastUpdated, delete i.resource.meta.project, delete i.resource.meta.versionId);
    let o = (_b = i.resource) == null ? void 0 : _b.id;
    o && (e[o] = oe(), i.fullUrl = "urn:uuid:" + e[o], (_c2 = i.resource) == null ? true : delete _c2.id);
  }
  let t = r4.entry, n = JSON.stringify({ resourceType: "Bundle", type: "transaction", entry: t == null ? void 0 : t.map((i) => ({ fullUrl: i.fullUrl, request: { method: "POST", url: i.resource.resourceType }, resource: i.resource })) }, (i, o) => Wo(i, o, e), 2);
  return Ko(JSON.parse(n));
}
function Wo(r4, e, t) {
  if (r4 === "reference" && typeof e == "string") {
    let n;
    if (e.includes("/") ? n = e.split("/")[1] : e.startsWith("urn:uuid:") ? n = e.slice(9) : e.startsWith("#") && (n = e.slice(1)), n) {
      let i = t[n];
      if (i)
        return "urn:uuid:" + i;
    }
  }
  return e;
}
function Ko(r4) {
  let e = Jo(r4), { sorted: t, cycles: n } = zo(e), i = {};
  for (let s of r4.entry || [])
    s.fullUrl && (i[s.fullUrl] = s);
  let o = t.map((s) => i[s]);
  for (let s of n)
    for (let a of s) {
      let c = i[a], u = { ...c, request: { ...c.request, method: "PUT" } };
      o.push(u);
    }
  return { ...r4, entry: o };
}
function zo(r4) {
  let e = [], t = {}, n = [];
  for (let o of Object.keys(r4))
    t[o] = 0;
  function i(o, s) {
    if (t[o] === 2)
      return true;
    if (t[o] === 1) {
      let c = s.lastIndexOf(o);
      return c !== -1 && n.push(s.slice(c)), true;
    }
    t[o] = 1, s.push(o);
    let a = false;
    for (let c of r4[o])
      i(c, s) || (a = true);
    return t[o] = 2, s.pop(), e.unshift(o), !a;
  }
  for (let o in r4)
    t[o] === 0 && i(o, []);
  return { sorted: e, cycles: n };
}
function Nn(r4, e) {
  for (let t in r4)
    if (r4[t] && typeof r4[t] == "object") {
      let n = r4[t];
      if (Y(n)) {
        let i = n.reference;
        i.startsWith("urn:uuid:") && e(i);
      } else
        Nn(n, e);
    }
}
function Jo(r4) {
  let e = {};
  for (let t of r4.entry || [])
    t.fullUrl && (e[t.fullUrl] = []);
  for (let t of r4.entry || []) {
    let n = t.fullUrl;
    t.resource && Nn(t.resource, (i) => {
      e[i] && e[i].push(n);
    });
  }
  return e;
}
function ml(r4) {
  r4 = ee(r4);
  let e = { resourceType: "Bundle", type: "transaction", entry: [{ resource: r4 }] };
  if (r4.contained) {
    for (let t of r4.contained)
      e.entry.push({ resource: t });
    r4.contained = void 0;
  }
  for (let t of e.entry)
    t.resource && !t.resource.id && (t.resource.id = oe());
  return Ho(e);
}
var mt = class {
  constructor(e = 10) {
    this.max = e, this.cache = /* @__PURE__ */ new Map();
  }
  clear() {
    this.cache.clear();
  }
  get(e) {
    let t = this.cache.get(e);
    return t && (this.cache.delete(e), this.cache.set(e, t)), t;
  }
  set(e, t) {
    this.cache.has(e) ? this.cache.delete(e) : this.cache.size >= this.max && this.cache.delete(this.first()), this.cache.set(e, t);
  }
  delete(e) {
    this.cache.delete(e);
  }
  keys() {
    return this.cache.keys();
  }
  first() {
    return this.cache.keys().next().value;
  }
};
var M = { CSS: "text/css", DICOM: "application/dicom", FAVICON: "image/vnd.microsoft.icon", FHIR_JSON: "application/fhir+json", FORM_URL_ENCODED: "application/x-www-form-urlencoded", HL7_V2: "x-application/hl7-v2+er7", HTML: "text/html", JAVASCRIPT: "text/javascript", JSON: "application/json", JSON_PATCH: "application/json-patch+json", PNG: "image/png", SVG: "image/svg+xml", TEXT: "text/plain", TYPESCRIPT: "text/typescript", PING: "x-application/ping" };
var ke = class {
  constructor() {
    this.listeners = {};
  }
  addEventListener(e, t) {
    this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t);
  }
  removeEventListener(e, t) {
    let n = this.listeners[e];
    if (n) {
      for (let i = 0; i < n.length; i++)
        if (n[i] === t) {
          n.splice(i, 1);
          return;
        }
    }
  }
  dispatchEvent(e) {
    let t = this.listeners[e.type];
    if (t)
      for (let n of t)
        n.call(this, e);
    return !e.defaultPrevented;
  }
};
var se = class {
  constructor() {
    this.emitter = new ke();
  }
  dispatchEvent(e) {
    this.emitter.dispatchEvent(e);
  }
  addEventListener(e, t) {
    this.emitter.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.emitter.removeEventListener(e, t);
  }
};
var dr = { "Patient-open": "Patient-open", "Patient-close": "Patient-close", "ImagingStudy-open": "ImagingStudy-open", "ImagingStudy-close": "ImagingStudy-close", "Encounter-open": "Encounter-open", "Encounter-close": "Encounter-close", "DiagnosticReport-open": "DiagnosticReport-open", "DiagnosticReport-close": "DiagnosticReport-close", "DiagnosticReport-select": "DiagnosticReport-select", "DiagnosticReport-update": "DiagnosticReport-update", syncerror: "syncerror" };
var Yo = ["Patient", "Encounter", "ImagingStudy", "DiagnosticReport", "OperationOutcome", "Bundle"];
var fr = ["DiagnosticReport-update"];
function _n(r4) {
  return fr.includes(r4);
}
function Un(r4) {
  if (fr.includes(r4))
    throw new d(m(`'context.version' is required for '${r4}'.`));
}
var Zo = { "Patient-open": { patient: { resourceType: "Patient" }, encounter: { resourceType: "Encounter", optional: true } }, "Patient-close": { patient: { resourceType: "Patient" }, encounter: { resourceType: "Encounter", optional: true } }, "ImagingStudy-open": { study: { resourceType: "ImagingStudy" }, encounter: { resourceType: "Encounter", optional: true }, patient: { resourceType: "Patient", optional: true } }, "ImagingStudy-close": { study: { resourceType: "ImagingStudy" }, encounter: { resourceType: "Encounter", optional: true }, patient: { resourceType: "Patient", optional: true } }, "Encounter-open": { encounter: { resourceType: "Encounter" }, patient: { resourceType: "Patient" } }, "Encounter-close": { encounter: { resourceType: "Encounter" }, patient: { resourceType: "Patient" } }, "DiagnosticReport-open": { report: { resourceType: "DiagnosticReport" }, encounter: { resourceType: "Encounter", optional: true }, study: { resourceType: "ImagingStudy", optional: true, manyAllowed: true }, patient: { resourceType: "Patient" } }, "DiagnosticReport-close": { report: { resourceType: "DiagnosticReport" }, encounter: { resourceType: "Encounter", optional: true }, study: { resourceType: "ImagingStudy", optional: true, manyAllowed: true }, patient: { resourceType: "Patient" } }, "DiagnosticReport-select": { report: { resourceType: "DiagnosticReport" }, select: { resourceType: "*", isArray: true } }, "DiagnosticReport-update": { report: { resourceType: "DiagnosticReport" }, patient: { resourceType: "Patient", optional: true }, study: { resourceType: "ImagingStudy", optional: true }, updates: { resourceType: "Bundle" } }, syncerror: { operationoutcome: { resourceType: "OperationOutcome" } } };
function Xo(r4) {
  return Yo.includes(r4);
}
function Ln(r4) {
  return !!r4.endpoint;
}
function mr(r4) {
  if (!yt(r4))
    throw new d(m("subscriptionRequest must be an object conforming to SubscriptionRequest type."));
  let { channelType: e, mode: t, topic: n, events: i } = r4, o = { "hub.channel.type": e, "hub.mode": t, "hub.topic": n, "hub.events": i.join(",") };
  return Ln(r4) && (o.endpoint = r4.endpoint), new URLSearchParams(o).toString();
}
function yt(r4) {
  if (typeof r4 != "object")
    return false;
  let { channelType: e, mode: t, topic: n, events: i } = r4;
  if (!(e && t && n && i) || typeof n != "string" || typeof i != "object" || !Array.isArray(i) || i.length < 1 || e !== "websocket" || t !== "subscribe" && t !== "unsubscribe")
    return false;
  for (let o of i)
    if (!dr[o])
      return false;
  return !(Ln(r4) && !(typeof r4.endpoint == "string" && r4.endpoint.startsWith("ws")));
}
function Fn(r4, e, t, n) {
  if (typeof e != "object")
    throw new d(m(`context[${t}] is invalid. Context must contain a single valid FHIR resource! Resource is not an object.`));
  if (!(e.id && typeof e.id == "string"))
    throw new d(m(`context[${t}] is invalid. Resource must contain a valid string ID.`));
  if (!e.resourceType)
    throw new d(m(`context[${t}] is invalid. Resource must contain a resource type. No resource type found.`));
  let i = n.resourceType;
  if (i !== "*") {
    if (!Xo(e.resourceType))
      throw new d(m(`context[${t}] is invalid. Resource must contain a valid FHIRcast resource type. Resource type is not a known resource type.`));
    if (i && e.resourceType !== i)
      throw new d(m(`context[${t}] is invalid. context[${t}] for the '${r4}' event should contain resource of type ${i}.`));
  }
}
function es(r4, e, t, n, i) {
  if (i.set(e.key, (i.get(e.key) ?? 0) + 1), !n.isArray)
    Fn(r4, e.resource, t, n);
  else {
    let { resources: o } = e;
    if (!o)
      throw new d(m(`context[${t}] is invalid. context[${t}] for the '${r4}' with key '${String(e.key)}' should contain an array of resources on the key 'resources'.`));
    for (let s of o)
      Fn(r4, s, t, n);
  }
}
function ts(r4, e) {
  let t = /* @__PURE__ */ new Map(), n = Zo[r4];
  for (let i = 0; i < e.length; i++) {
    let o = e[i].key;
    if (!n[o])
      throw new d(m(`Key '${o}' not found for event '${r4}'. Make sure to add only valid keys.`));
    es(r4, e[i], i, n[o], t);
  }
  for (let [i, o] of Object.entries(n)) {
    if (!(o.optional || t.has(i)))
      throw new d(m(`Missing required key '${i}' on context for '${r4}' event.`));
    if (!o.manyAllowed && (t.get(i) || 0) > 1)
      throw new d(m(`${t.get(i)} context entries with key '${i}' found for the '${r4}' event when schema only allows for 1.`));
  }
}
function hr(r4, e, t, n) {
  if (!(r4 && typeof r4 == "string"))
    throw new d(m("Must provide a topic."));
  if (!dr[e])
    throw new d(m(`Must provide a valid FHIRcast event name. Supported events: ${Object.keys(dr).join(", ")}`));
  if (typeof t != "object")
    throw new d(m("context must be a context object or array of context objects."));
  if (fr.includes(e) && !n)
    throw new d(m(`The '${e}' event must contain a 'context.versionId'.`));
  let i = Array.isArray(t) ? t : [t];
  return ts(e, i), { timestamp: (/* @__PURE__ */ new Date()).toISOString(), id: oe(), event: { "hub.topic": r4, "hub.event": e, context: i, ...n ? { "context.versionId": n } : {} } };
}
var ht = class extends se {
  constructor(e) {
    if (super(), this.subRequest = e, !e.endpoint)
      throw new d(m("Subscription request should contain an endpoint."));
    if (!yt(e))
      throw new d(m("Subscription request failed validation."));
    let t = new WebSocket(e.endpoint);
    t.addEventListener("open", () => {
      this.dispatchEvent({ type: "connect" }), t.addEventListener("message", (n) => {
        let i = JSON.parse(n.data);
        if (i["hub.topic"])
          return;
        let o = i;
        o.event["hub.event"] !== "heartbeat" && (this.dispatchEvent({ type: "message", payload: o }), t.send(JSON.stringify({ id: i == null ? void 0 : i.id, timestamp: (/* @__PURE__ */ new Date()).toISOString() })));
      }), t.addEventListener("close", () => {
        this.dispatchEvent({ type: "disconnect" });
      });
    }), this.websocket = t;
  }
  disconnect() {
    this.websocket.close();
  }
};
function rs(r4) {
  let e = r4.replace(/-/g, "+").replace(/_/g, "/"), t = Vn(e), n = Array.from(t).reduce((o, s) => {
    let a = ("00" + s.charCodeAt(0).toString(16)).slice(-2);
    return `${o}%${a}`;
  }, ""), i = decodeURIComponent(n);
  return JSON.parse(i);
}
function Bn(r4) {
  return r4.split(".").length === 3;
}
function gt(r4) {
  let [e, t, n] = r4.split(".");
  return rs(t);
}
function qn(r4) {
  try {
    return typeof gt(r4).login_id == "string";
  } catch {
    return false;
  }
}
function jn(r4) {
  try {
    let t = gt(r4).exp;
    return typeof t == "number" ? t * 1e3 : void 0;
  } catch {
    return;
  }
}
var ns;
var k = class {
  constructor(e) {
    this[ns] = "ReadablePromise";
    this.status = "pending";
    this.suspender = e.then((t) => (this.status = "success", this.response = t, t), (t) => {
      throw this.status = "error", this.error = t, t;
    });
  }
  isPending() {
    return this.status === "pending";
  }
  isOk() {
    return this.status === "success";
  }
  read() {
    switch (this.status) {
      case "pending":
        throw this.suspender;
      case "error":
        throw this.error;
      default:
        return this.response;
    }
  }
  then(e, t) {
    return this.suspender.then(e, t);
  }
  catch(e) {
    return this.suspender.catch(e);
  }
  finally(e) {
    return this.suspender.finally(e);
  }
};
ns = Symbol.toStringTag;
var Oe = class {
  constructor(e) {
    this.storage = e ?? (typeof localStorage < "u" ? localStorage : new yr());
  }
  clear() {
    this.storage.clear();
  }
  getString(e) {
    return this.storage.getItem(e) ?? void 0;
  }
  setString(e, t) {
    t ? this.storage.setItem(e, t) : this.storage.removeItem(e);
  }
  getObject(e) {
    let t = this.getString(e);
    return t ? JSON.parse(t) : void 0;
  }
  setObject(e, t) {
    this.setString(e, t ? ln(t) : void 0);
  }
};
var yr = class {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  get length() {
    return this.data.size;
  }
  clear() {
    this.data.clear();
  }
  getItem(e) {
    return this.data.get(e) ?? null;
  }
  setItem(e, t) {
    t ? this.data.set(e, t) : this.data.delete(e);
  }
  removeItem(e) {
    this.data.delete(e);
  }
  key(e) {
    return Array.from(this.data.keys())[e];
  }
};
var $n = class extends Oe {
  constructor() {
    super();
    this.initResolve = () => {
    };
    this.initialized = false, this.initPromise = new Promise((t) => {
      this.initResolve = t;
    });
  }
  setInitialized() {
    this.initialized || (this.initResolve(), this.initialized = true);
  }
  getInitPromise() {
    return this.initPromise;
  }
  get isInitialized() {
    return this.initialized;
  }
};
var gr = class extends se {
  constructor(t) {
    super();
    this.bufferedAmount = -1 / 0;
    this.extensions = "NOT_IMPLEMENTED";
    this.messageBuffer = [];
    let n = new WebSocket(t);
    n.addEventListener("open", () => {
      if (this.messageBuffer.length) {
        let i = this.messageBuffer;
        for (let o of i)
          n.send(o);
      }
      this.dispatchEvent(new Event("open"));
    }), n.addEventListener("error", (i) => {
      this.dispatchEvent(i);
    }), n.addEventListener("message", (i) => {
      this.dispatchEvent(i);
    }), n.addEventListener("close", (i) => {
      this.dispatchEvent(i);
    }), this.ws = n;
  }
  get readyState() {
    return this.ws.readyState;
  }
  close() {
    this.ws.close();
  }
  send(t) {
    if (this.ws.readyState !== WebSocket.OPEN) {
      this.messageBuffer.push(t);
      return;
    }
    try {
      this.ws.send(t);
    } catch (n) {
      this.dispatchEvent(new ErrorEvent("error", { error: n, message: n.message })), this.messageBuffer.push(t);
    }
  }
};
var Ve = class extends se {
  constructor(...e) {
    super(), this.criteria = new Set(e);
  }
  getCriteria() {
    return this.criteria;
  }
  _addCriteria(e) {
    this.criteria.add(e);
  }
  _removeCriteria(e) {
    this.criteria.delete(e);
  }
};
var xr = class {
  constructor(e) {
    this.criteria = e, this.emitter = new Ve(e), this.refCount = 1;
  }
};
var xt = class {
  constructor(e, t) {
    if (!(e instanceof vt))
      throw new d(m("First arg of constructor should be a `MedplumClient`"));
    let n;
    try {
      n = new URL(t).toString();
    } catch {
      throw new d(m("Not a valid URL"));
    }
    let i = new gr(n);
    this.medplum = e, this.ws = i, this.masterSubEmitter = new Ve(), this.criteriaEntries = /* @__PURE__ */ new Map(), this.criteriaEntriesBySubscriptionId = /* @__PURE__ */ new Map(), this.wsClosed = false, this.setupWebSocketListeners();
  }
  setupWebSocketListeners() {
    let e = this.ws;
    e.addEventListener("message", (t) => {
      var _a, _b, _c2, _d, _e2;
      try {
        let n = JSON.parse(t.data), i = (_b = (_a = n == null ? void 0 : n.entry) == null ? void 0 : _a[0]) == null ? void 0 : _b.resource;
        if (i.type === "heartbeat") {
          (_c2 = this.masterSubEmitter) == null ? void 0 : _c2.dispatchEvent({ type: "heartbeat", payload: n });
          return;
        }
        (_d = this.masterSubEmitter) == null ? void 0 : _d.dispatchEvent({ type: "message", payload: n });
        let o = this.criteriaEntriesBySubscriptionId.get(Je(i.subscription));
        if (!o) {
          console.warn("Received notification for criteria the SubscriptionManager is not listening for");
          return;
        }
        o.emitter.dispatchEvent({ type: "message", payload: n });
      } catch (n) {
        console.error(n);
        let i = { type: "error", payload: n };
        (_e2 = this.masterSubEmitter) == null ? void 0 : _e2.dispatchEvent(i);
        for (let { emitter: o } of this.criteriaEntries.values())
          o.dispatchEvent(i);
      }
    }), e.addEventListener("error", () => {
      var _a;
      let t = { type: "error", payload: new d(Mr(new Error("WebSocket error"))) };
      (_a = this.masterSubEmitter) == null ? void 0 : _a.dispatchEvent(t);
      for (let { emitter: n } of this.criteriaEntries.values())
        n.dispatchEvent(t);
    }), e.addEventListener("close", () => {
      var _a;
      let t = { type: "close" };
      this.wsClosed && ((_a = this.masterSubEmitter) == null ? void 0 : _a.dispatchEvent(t));
      for (let { emitter: n } of this.criteriaEntries.values())
        n.dispatchEvent(t);
    });
  }
  emitConnect(e) {
    var _a;
    let t = { type: "connect", payload: { subscriptionId: e } };
    (_a = this.masterSubEmitter) == null ? void 0 : _a.dispatchEvent(t);
    for (let { emitter: n } of this.criteriaEntries.values())
      n.dispatchEvent(t);
  }
  emitError(e, t) {
    var _a, _b, _c2;
    let n = { type: "error", payload: t };
    (_a = this.masterSubEmitter) == null ? void 0 : _a.dispatchEvent(n), (_c2 = (_b = this.criteriaEntries.get(e)) == null ? void 0 : _b.emitter) == null ? void 0 : _c2.dispatchEvent(n);
  }
  async getTokenForCriteria(e) {
    var _a, _b;
    let t = e == null ? void 0 : e.subscriptionId;
    t || (t = (await this.medplum.createResource({ resourceType: "Subscription", status: "active", reason: `WebSocket subscription for ${X(this.medplum.getProfile())}`, criteria: e.criteria, channel: { type: "websocket" } })).id);
    let { parameter: n } = await this.medplum.get(`/fhir/R4/Subscription/${t}/$get-ws-binding-token`), i = (_a = n == null ? void 0 : n.find((s) => s.name === "token")) == null ? void 0 : _a.valueString, o = (_b = n == null ? void 0 : n.find((s) => s.name === "websocket-url")) == null ? void 0 : _b.valueUrl;
    if (!i)
      throw new d(m("Failed to get token"));
    if (!o)
      throw new d(m("Failed to get URL from $get-ws-binding-token"));
    return [t, i];
  }
  addCriteria(e) {
    this.masterSubEmitter && this.masterSubEmitter._addCriteria(e);
    let t = this.criteriaEntries.get(e);
    if (t)
      return t.refCount += 1, t.emitter;
    let n = new xr(e);
    return this.criteriaEntries.set(e, n), this.getTokenForCriteria(n).then(([i, o]) => {
      n.subscriptionId = i, this.criteriaEntriesBySubscriptionId.set(i, n), this.emitConnect(i), this.ws.send(JSON.stringify({ type: "bind-with-token", payload: { token: o } }));
    }).catch((i) => {
      console.error(i.message), this.emitError(e, i), this.criteriaEntries.delete(e);
    }), n.emitter;
  }
  removeCriteria(e) {
    var _a, _b, _c2;
    let t = this.criteriaEntries.get(e);
    if (!t) {
      console.warn("Criteria not known to `SubscriptionManager`. Possibly called remove too many times.");
      return;
    }
    if (t.refCount -= 1, t.refCount > 0)
      return;
    let n = (_a = this.criteriaEntries.get(e)) == null ? void 0 : _a.subscriptionId, i = { type: "disconnect", payload: { subscriptionId: n } };
    this.masterSubEmitter && (this.masterSubEmitter._removeCriteria(e), this.masterSubEmitter.dispatchEvent(i)), (_c2 = (_b = this.criteriaEntries.get(e)) == null ? void 0 : _b.emitter) == null ? void 0 : _c2.dispatchEvent(i), this.criteriaEntries.delete(e), n && this.criteriaEntriesBySubscriptionId.delete(n);
  }
  closeWebSocket() {
    this.wsClosed || (this.wsClosed = true, this.ws.close());
  }
  getCriteriaCount() {
    return this.criteriaEntries.size;
  }
  getMasterEmitter() {
    return this.masterSubEmitter || (this.masterSubEmitter = new Ve(...Array.from(this.criteriaEntries.keys()))), this.masterSubEmitter;
  }
};
var Tt = class {
  constructor(e) {
    this.medplum = e;
  }
  async get(e) {
    return this.medplum.get(`keyvalue/v1/${e}`);
  }
  async set(e, t) {
    await this.medplum.put(`keyvalue/v1/${e}`, t);
  }
  async delete(e) {
    await this.medplum.delete(`keyvalue/v1/${e}`);
  }
};
var ap = "3.0.9-1021a026";
var is = M.FHIR_JSON + ", */*; q=0.1";
var os = "https://api.medplum.com/";
var ss = 1e3;
var as = 6e4;
var cs = 0;
var Gn = "Binary/";
var Qn = { resourceType: "Device", id: "system", deviceName: [{ type: "model-name", name: "System" }] };
var us = ((o) => (o.ClientCredentials = "client_credentials", o.AuthorizationCode = "authorization_code", o.RefreshToken = "refresh_token", o.JwtBearer = "urn:ietf:params:oauth:grant-type:jwt-bearer", o.TokenExchange = "urn:ietf:params:oauth:grant-type:token-exchange", o))(us || {});
var ls = ((o) => (o.AccessToken = "urn:ietf:params:oauth:token-type:access_token", o.RefreshToken = "urn:ietf:params:oauth:token-type:refresh_token", o.IdToken = "urn:ietf:params:oauth:token-type:id_token", o.Saml1Token = "urn:ietf:params:oauth:token-type:saml1", o.Saml2Token = "urn:ietf:params:oauth:token-type:saml2", o))(ls || {});
var ps = ((o) => (o.ClientSecretBasic = "client_secret_basic", o.ClientSecretPost = "client_secret_post", o.ClientSecretJwt = "client_secret_jwt", o.PrivateKeyJwt = "private_key_jwt", o.None = "none", o))(ps || {});
var ds = ((e) => (e.JwtBearer = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer", e))(ds || {});
var vt = class extends ke {
  constructor(t) {
    super();
    this.initComplete = true;
    if ((t == null ? void 0 : t.baseUrl) && !t.baseUrl.startsWith("http"))
      throw new Error("Base URL must start with http or https");
    if (this.options = t ?? {}, this.fetch = (t == null ? void 0 : t.fetch) ?? fs(), this.storage = (t == null ? void 0 : t.storage) ?? new Oe(), this.createPdfImpl = t == null ? void 0 : t.createPdf, this.baseUrl = Wn((t == null ? void 0 : t.baseUrl) ?? os), this.fhirBaseUrl = Wn(St(this.baseUrl, (t == null ? void 0 : t.fhirUrlPath) ?? "fhir/R4/")), this.authorizeUrl = St(this.baseUrl, (t == null ? void 0 : t.authorizeUrl) ?? "oauth2/authorize"), this.tokenUrl = St(this.baseUrl, (t == null ? void 0 : t.tokenUrl) ?? "oauth2/token"), this.logoutUrl = St(this.baseUrl, (t == null ? void 0 : t.logoutUrl) ?? "oauth2/logout"), this.clientId = (t == null ? void 0 : t.clientId) ?? "", this.clientSecret = (t == null ? void 0 : t.clientSecret) ?? "", this.onUnauthenticated = t == null ? void 0 : t.onUnauthenticated, this.cacheTime = (t == null ? void 0 : t.cacheTime) ?? (typeof window > "u" ? cs : as), this.cacheTime > 0 ? this.requestCache = new mt((t == null ? void 0 : t.resourceCacheSize) ?? ss) : this.requestCache = void 0, (t == null ? void 0 : t.autoBatchTime) ? (this.autoBatchTime = t.autoBatchTime, this.autoBatchQueue = []) : (this.autoBatchTime = 0, this.autoBatchQueue = void 0), t == null ? void 0 : t.accessToken)
      this.setAccessToken(t.accessToken), this.initPromise = Promise.resolve();
    else if (this.storage.getInitPromise !== void 0) {
      let n = this.storage.getInitPromise(), i = new Promise((o) => {
        n.then(() => {
          this.attemptResumeActiveLogin().then(o).catch(console.error), this.initComplete = true;
        }).catch(console.error);
      });
      this.initPromise = i, this.initComplete = false;
    } else
      this.initPromise = this.attemptResumeActiveLogin().catch(console.error);
    this.setupStorageListener();
  }
  get isInitialized() {
    return this.initComplete;
  }
  getInitPromise() {
    return this.initPromise;
  }
  async attemptResumeActiveLogin() {
    let t = this.getActiveLogin();
    t && (this.setAccessToken(t.accessToken, t.refreshToken), await this.refreshProfile());
  }
  getBaseUrl() {
    return this.baseUrl;
  }
  getAuthorizeUrl() {
    return this.authorizeUrl;
  }
  getTokenUrl() {
    return this.tokenUrl;
  }
  getLogoutUrl() {
    return this.logoutUrl;
  }
  clear() {
    this.storage.clear(), sessionStorage.clear(), this.clearActiveLogin();
  }
  clearActiveLogin() {
    var _a;
    this.storage.setString("activeLogin", void 0), (_a = this.requestCache) == null ? void 0 : _a.clear(), this.accessToken = void 0, this.refreshToken = void 0, this.refreshPromise = void 0, this.accessTokenExpires = void 0, this.sessionDetails = void 0, this.medplumServer = void 0, this.dispatchEvent({ type: "change" });
  }
  invalidateUrl(t) {
    var _a;
    t = t.toString(), (_a = this.requestCache) == null ? void 0 : _a.delete(t);
  }
  invalidateAll() {
    var _a;
    (_a = this.requestCache) == null ? void 0 : _a.clear();
  }
  invalidateSearches(t) {
    let n = this.fhirBaseUrl + t;
    if (this.requestCache)
      for (let i of this.requestCache.keys())
        (i.endsWith(n) || i.includes(n + "?")) && this.requestCache.delete(i);
  }
  get(t, n = {}) {
    t = t.toString();
    let i = this.getCacheEntry(t, n);
    if (i)
      return i.value;
    let o;
    t.startsWith(this.fhirBaseUrl) && this.autoBatchQueue ? o = new Promise((a, c) => {
      this.autoBatchQueue.push({ method: "GET", url: t.replace(this.fhirBaseUrl, ""), options: n, resolve: a, reject: c }), this.autoBatchTimerId || (this.autoBatchTimerId = setTimeout(() => this.executeAutoBatch(), this.autoBatchTime));
    }) : o = this.request("GET", t, n);
    let s = new k(o);
    return this.setCacheEntry(t, s), s;
  }
  post(t, n, i, o = {}) {
    return t = t.toString(), this.setRequestBody(o, n), i && this.setRequestContentType(o, i), this.invalidateUrl(t), this.request("POST", t, o);
  }
  put(t, n, i, o = {}) {
    return t = t.toString(), this.setRequestBody(o, n), i && this.setRequestContentType(o, i), this.invalidateUrl(t), this.request("PUT", t, o);
  }
  patch(t, n, i = {}) {
    return t = t.toString(), this.setRequestBody(i, n), this.setRequestContentType(i, M.JSON_PATCH), this.invalidateUrl(t), this.request("PATCH", t, i);
  }
  delete(t, n) {
    return t = t.toString(), this.invalidateUrl(t), this.request("DELETE", t, n);
  }
  async startNewUser(t, n) {
    let { codeChallengeMethod: i, codeChallenge: o } = await this.startPkce();
    return this.post("auth/newuser", { ...t, clientId: t.clientId ?? this.clientId, codeChallengeMethod: i, codeChallenge: o }, void 0, n);
  }
  async startNewProject(t, n) {
    return this.post("auth/newproject", t, void 0, n);
  }
  async startNewPatient(t, n) {
    return this.post("auth/newpatient", t, void 0, n);
  }
  async startLogin(t, n) {
    return this.post("auth/login", { ...await this.ensureCodeChallenge(t), clientId: t.clientId ?? this.clientId, scope: t.scope }, void 0, n);
  }
  async startGoogleLogin(t, n) {
    return this.post("auth/google", { ...await this.ensureCodeChallenge(t), clientId: t.clientId ?? this.clientId, scope: t.scope }, void 0, n);
  }
  async ensureCodeChallenge(t) {
    return t.codeChallenge ? t : { ...t, ...await this.startPkce() };
  }
  async signOut() {
    await this.post(this.logoutUrl, {}), this.clear();
  }
  async signInWithRedirect(t) {
    let i = new URLSearchParams(window.location.search).get("code");
    if (!i) {
      await this.requestAuthorization(t);
      return;
    }
    return this.processCode(i);
  }
  signOutWithRedirect() {
    window.location.assign(this.logoutUrl);
  }
  async signInWithExternalAuth(t, n, i, o, s = true) {
    let a = o;
    s && (a = await this.ensureCodeChallenge(o)), window.location.assign(this.getExternalAuthRedirectUri(t, n, i, a, s));
  }
  async exchangeExternalAccessToken(t, n) {
    if (n = n ?? this.clientId, !n)
      throw new Error("MedplumClient is missing clientId");
    let i = new URLSearchParams();
    return i.set("grant_type", "urn:ietf:params:oauth:grant-type:token-exchange"), i.set("subject_token_type", "urn:ietf:params:oauth:token-type:access_token"), i.set("client_id", n), i.set("subject_token", t), this.fetchTokens(i);
  }
  getExternalAuthRedirectUri(t, n, i, o, s = true) {
    let a = new URL(t);
    if (a.searchParams.set("response_type", "code"), a.searchParams.set("client_id", n), a.searchParams.set("redirect_uri", i), a.searchParams.set("scope", o.scope ?? "openid profile email"), a.searchParams.set("state", JSON.stringify(o)), s) {
      let { codeChallenge: c, codeChallengeMethod: u } = o;
      if (!u)
        throw new Error("`LoginRequest` for external auth must include a `codeChallengeMethod`.");
      if (!c)
        throw new Error("`LoginRequest` for external auth must include a `codeChallenge`.");
      a.searchParams.set("code_challenge_method", u), a.searchParams.set("code_challenge", c);
    }
    return a.toString();
  }
  fhirUrl(...t) {
    return new URL(t.join("/"), this.fhirBaseUrl);
  }
  fhirSearchUrl(t, n) {
    let i = this.fhirUrl(t);
    return n && (i.search = new URLSearchParams(n).toString()), i;
  }
  search(t, n, i) {
    let o = this.fhirSearchUrl(t, n), s = "search-" + o.toString(), a = this.getCacheEntry(s, i);
    if (a)
      return a.value;
    let c = new k((async () => {
      let u = await this.get(o, i);
      if (u.entry)
        for (let p of u.entry)
          this.cacheResource(p.resource);
      return u;
    })());
    return this.setCacheEntry(s, c), c;
  }
  searchOne(t, n, i) {
    let o = this.fhirSearchUrl(t, n);
    o.searchParams.set("_count", "1"), o.searchParams.sort();
    let s = "searchOne-" + o.toString(), a = this.getCacheEntry(s, i);
    if (a)
      return a.value;
    let c = new k(this.search(t, o.searchParams, i).then((u) => {
      var _a, _b;
      return (_b = (_a = u.entry) == null ? void 0 : _a[0]) == null ? void 0 : _b.resource;
    }));
    return this.setCacheEntry(s, c), c;
  }
  searchResources(t, n, i) {
    let s = "searchResources-" + this.fhirSearchUrl(t, n).toString(), a = this.getCacheEntry(s, i);
    if (a)
      return a.value;
    let c = new k(this.search(t, n, i).then(vr));
    return this.setCacheEntry(s, c), c;
  }
  async *searchResourcePages(t, n, i) {
    var _a, _b;
    let o = this.fhirSearchUrl(t, n);
    for (; o; ) {
      let s = new URL(o).searchParams, a = await this.search(t, s, i), c = (_a = a.link) == null ? void 0 : _a.find((u) => u.relation === "next");
      if (!((_b = a.entry) == null ? void 0 : _b.length) && !c)
        break;
      yield vr(a), o = (c == null ? void 0 : c.url) ? new URL(c.url) : void 0;
    }
  }
  searchValueSet(t, n, i) {
    return this.valueSetExpand({ url: t, filter: n }, i);
  }
  valueSetExpand(t, n) {
    let i = this.fhirUrl("ValueSet", "$expand");
    return i.search = new URLSearchParams(t).toString(), this.get(i.toString(), n);
  }
  getCached(t, n) {
    var _a, _b;
    let i = (_b = (_a = this.requestCache) == null ? void 0 : _a.get(this.fhirUrl(t, n).toString())) == null ? void 0 : _b.value;
    return (i == null ? void 0 : i.isOk()) ? i.read() : void 0;
  }
  getCachedReference(t) {
    let n = t.reference;
    if (!n)
      return;
    if (n === "system")
      return Qn;
    let [i, o] = n.split("/");
    if (!(!i || !o))
      return this.getCached(i, o);
  }
  readResource(t, n, i) {
    return this.get(this.fhirUrl(t, n), i);
  }
  readReference(t, n) {
    let i = t.reference;
    if (!i)
      return new k(Promise.reject(new Error("Missing reference")));
    if (i === "system")
      return new k(Promise.resolve(Qn));
    let [o, s] = i.split("/");
    return !o || !s ? new k(Promise.reject(new Error("Invalid reference"))) : this.readResource(o, s, n);
  }
  requestSchema(t) {
    if (Qr(t))
      return Promise.resolve();
    let n = t + "-requestSchema", i = this.getCacheEntry(n, void 0);
    if (i)
      return i.value;
    let o = new k((async () => {
      let s = `{
      StructureDefinitionList(name: "${t}") {
        resourceType,
        name,
        kind,
        description,
        type,
        snapshot {
          element {
            id,
            path,
            definition,
            min,
            max,
            base {
              path,
              min,
              max
            },
            contentReference,
            type {
              code,
              profile,
              targetProfile
            },
            binding {
              strength,
              valueSet
            }
          }
        }
      }
      SearchParameterList(base: "${t}", _count: 100) {
        base,
        code,
        type,
        expression,
        target
      }
    }`.replace(/\s+/g, " "), a = await this.graphql(s);
      qt(a.data.StructureDefinitionList);
      for (let c of a.data.SearchParameterList)
        or(c);
    })());
    return this.setCacheEntry(n, o), o;
  }
  requestProfileSchema(t, n) {
    if (!(n == null ? void 0 : n.expandProfile) && Wr(t))
      return Promise.resolve([t]);
    let i = t + "-requestSchema" + ((n == null ? void 0 : n.expandProfile) ? "-nested" : ""), o = this.getCacheEntry(i, void 0);
    if (o)
      return o.value;
    let s = new k((async () => {
      if (n == null ? void 0 : n.expandProfile) {
        let a = this.fhirUrl("StructureDefinition", "$expand-profile");
        a.search = new URLSearchParams({ url: t }).toString();
        let c = await this.post(a.toString(), {});
        return vr(c).map((u) => (jt(u, u.url), u.url));
      } else {
        let a = await this.searchOne("StructureDefinition", { url: t, _sort: "-_lastUpdated" });
        return a ? (qt([a], t), [t]) : (console.warn(`No StructureDefinition found for ${t}!`), []);
      }
    })());
    return this.setCacheEntry(i, s), s;
  }
  readHistory(t, n, i) {
    return this.get(this.fhirUrl(t, n, "_history"), i);
  }
  readVersion(t, n, i, o) {
    return this.get(this.fhirUrl(t, n, "_history", i), o);
  }
  readPatientEverything(t, n) {
    return this.get(this.fhirUrl("Patient", t, "$everything"), n);
  }
  createResource(t, n) {
    if (!t.resourceType)
      throw new Error("Missing resourceType");
    return this.invalidateSearches(t.resourceType), this.post(this.fhirUrl(t.resourceType), t, void 0, n);
  }
  async createResourceIfNoneExist(t, n, i) {
    return await this.searchOne(t.resourceType, n, i) ?? this.createResource(t, i);
  }
  async createAttachment(t, n, i, o, s) {
    let a = await this.createBinary(t, n, i, o, s);
    return { contentType: i, url: a.url, title: n };
  }
  createBinary(t, n, i, o, s) {
    let a = this.fhirUrl("Binary");
    return n && a.searchParams.set("_filename", n), o ? this.uploadwithProgress(a, t, i, o, s) : this.post(a, t, i, s);
  }
  uploadwithProgress(t, n, i, o, s) {
    return new Promise((a, c) => {
      var _a;
      let u = new XMLHttpRequest(), p = () => u.abort();
      (_a = s == null ? void 0 : s.signal) == null ? void 0 : _a.addEventListener("abort", p);
      let x = (v) => {
        var _a2;
        (_a2 = s == null ? void 0 : s.signal) == null ? void 0 : _a2.removeEventListener("abort", p), v instanceof Error ? c(v) : a(v);
      };
      u.responseType = "json", u.onabort = () => x(new Error("Request aborted")), u.onerror = () => x(new Error("Request error")), o && (u.upload.onprogress = (v) => o(v), u.upload.onload = (v) => o(v)), u.onload = () => {
        u.status >= 200 && u.status < 300 ? x(u.response) : x(new d(Be(u.response || u.statusText)));
      }, u.open("POST", t), u.withCredentials = true, u.setRequestHeader("Authorization", "Bearer " + this.accessToken), u.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0"), u.setRequestHeader("Content-Type", i), u.setRequestHeader("X-Medplum", "extended"), u.send(n);
    });
  }
  async createPdf(t, n, i, o) {
    if (!this.createPdfImpl)
      throw new Error("PDF creation not enabled");
    let s = await this.createPdfImpl(t, i, o);
    return this.createBinary(s, n, "application/pdf");
  }
  createComment(t, n, i) {
    let o = this.getProfile(), s, a;
    return t.resourceType === "Encounter" && (s = Z(t), a = t.subject), t.resourceType === "ServiceRequest" && (s = t.encounter, a = t.subject), t.resourceType === "Patient" && (a = Z(t)), this.createResource({ resourceType: "Communication", status: "completed", basedOn: [Z(t)], encounter: s, subject: a, sender: o ? Z(o) : void 0, sent: (/* @__PURE__ */ new Date()).toISOString(), payload: [{ contentString: n }] }, i);
  }
  async updateResource(t, n) {
    if (!t.resourceType)
      throw new Error("Missing resourceType");
    if (!t.id)
      throw new Error("Missing id");
    let i = await this.put(this.fhirUrl(t.resourceType, t.id), t, void 0, n);
    return i || (i = t), this.cacheResource(i), this.invalidateUrl(this.fhirUrl(t.resourceType, t.id, "_history")), this.invalidateSearches(t.resourceType), i;
  }
  patchResource(t, n, i, o) {
    return this.invalidateSearches(t), this.patch(this.fhirUrl(t, n), i, o);
  }
  deleteResource(t, n, i) {
    return this.deleteCacheEntry(this.fhirUrl(t, n).toString()), this.invalidateSearches(t), this.delete(this.fhirUrl(t, n), i);
  }
  validateResource(t, n) {
    return this.post(this.fhirUrl(t.resourceType, "$validate"), t, void 0, n);
  }
  executeBot(t, n, i, o) {
    let s;
    if (typeof t == "string") {
      let a = t;
      s = this.fhirUrl("Bot", a, "$execute");
    } else {
      let a = t;
      s = this.fhirUrl("Bot", "$execute"), s.searchParams.set("identifier", a.system + "|" + a.value);
    }
    return this.post(s, n, i, o);
  }
  executeBatch(t, n) {
    return this.post(this.fhirBaseUrl.slice(0, -1), t, void 0, n);
  }
  sendEmail(t, n) {
    return this.post("email/v1/send", t, M.JSON, n);
  }
  graphql(t, n, i, o) {
    return this.post(this.fhirUrl("$graphql"), { query: t, operationName: n, variables: i }, M.JSON, o);
  }
  readResourceGraph(t, n, i, o) {
    return this.get(`${this.fhirUrl(t, n)}/$graph?graph=${i}`, o);
  }
  pushToAgent(t, n, i, o, s, a) {
    return this.post(this.fhirUrl("Agent", Je(t), "$push"), { destination: typeof n == "string" ? n : X(n), body: i, contentType: o, waitForResponse: s }, M.FHIR_JSON, a);
  }
  getActiveLogin() {
    return this.storage.getObject("activeLogin");
  }
  async setActiveLogin(t) {
    var _a, _b;
    (!((_a = this.sessionDetails) == null ? void 0 : _a.profile) || X(this.sessionDetails.profile) !== ((_b = t.profile) == null ? void 0 : _b.reference)) && this.clearActiveLogin(), this.setAccessToken(t.accessToken, t.refreshToken), this.storage.setObject("activeLogin", t), this.addLogin(t), this.refreshPromise = void 0, await this.refreshProfile();
  }
  getAccessToken() {
    return this.accessToken;
  }
  setAccessToken(t, n) {
    this.accessToken = t, this.refreshToken = n, this.sessionDetails = void 0, this.accessTokenExpires = jn(t), this.medplumServer = qn(t);
  }
  getLogins() {
    return this.storage.getObject("logins") ?? [];
  }
  addLogin(t) {
    let n = this.getLogins().filter((i) => {
      var _a, _b;
      return ((_a = i.profile) == null ? void 0 : _a.reference) !== ((_b = t.profile) == null ? void 0 : _b.reference);
    });
    n.push(t), this.storage.setObject("logins", n);
  }
  async refreshProfile() {
    return this.medplumServer ? (this.profilePromise = new Promise((t, n) => {
      this.get("auth/me").then((i) => {
        var _a, _b;
        this.profilePromise = void 0;
        let o = ((_b = (_a = this.sessionDetails) == null ? void 0 : _a.profile) == null ? void 0 : _b.id) !== i.profile.id;
        this.sessionDetails = i, o && this.dispatchEvent({ type: "change" }), t(i.profile);
      }).catch(n);
    }), this.profilePromise) : Promise.resolve(void 0);
  }
  isLoading() {
    return !this.isInitialized || !!this.profilePromise;
  }
  isSuperAdmin() {
    var _a;
    return !!((_a = this.sessionDetails) == null ? void 0 : _a.project.superAdmin);
  }
  isProjectAdmin() {
    var _a;
    return !!((_a = this.sessionDetails) == null ? void 0 : _a.membership.admin);
  }
  getProject() {
    var _a;
    return (_a = this.sessionDetails) == null ? void 0 : _a.project;
  }
  getProjectMembership() {
    var _a;
    return (_a = this.sessionDetails) == null ? void 0 : _a.membership;
  }
  getProfile() {
    var _a;
    return (_a = this.sessionDetails) == null ? void 0 : _a.profile;
  }
  async getProfileAsync() {
    return this.profilePromise ? this.profilePromise : this.sessionDetails ? this.sessionDetails.profile : this.refreshProfile();
  }
  getUserConfiguration() {
    var _a;
    return (_a = this.sessionDetails) == null ? void 0 : _a.config;
  }
  getAccessPolicy() {
    var _a;
    return (_a = this.sessionDetails) == null ? void 0 : _a.accessPolicy;
  }
  async download(t, n = {}) {
    this.refreshPromise && await this.refreshPromise;
    let i = t.toString();
    return i.startsWith(Gn) && (t = this.fhirUrl(i)), this.addFetchOptionsDefaults(n), (await this.fetchWithRetry(t.toString(), n)).blob();
  }
  async uploadMedia(t, n, i, o, s) {
    let a = await this.createBinary(t, i, n);
    return this.createResource({ resourceType: "Media", status: "completed", content: { contentType: n, url: Gn + a.id, title: i }, ...o }, s);
  }
  async bulkExport(t = "", n, i, o) {
    let s = t && `${t}/`, a = this.fhirUrl(`${s}$export`);
    return n && a.searchParams.set("_type", n), i && a.searchParams.set("_since", i), this.startAsyncRequest(a.toString(), o);
  }
  async startAsyncRequest(t, n = {}) {
    this.addFetchOptionsDefaults(n);
    let i = n.headers;
    return i.Prefer = "respond-async", this.request("POST", t, n);
  }
  get keyValue() {
    return this.keyValueClient || (this.keyValueClient = new Tt(this)), this.keyValueClient;
  }
  getCacheEntry(t, n) {
    if (!this.requestCache || (n == null ? void 0 : n.cache) === "no-cache" || (n == null ? void 0 : n.cache) === "reload")
      return;
    let i = this.requestCache.get(t);
    if (!(!i || i.requestTime + this.cacheTime < Date.now()))
      return i;
  }
  setCacheEntry(t, n) {
    this.requestCache && this.requestCache.set(t, { requestTime: Date.now(), value: n });
  }
  cacheResource(t) {
    var _a, _b;
    (t == null ? void 0 : t.id) && !((_b = (_a = t.meta) == null ? void 0 : _a.tag) == null ? void 0 : _b.some((n) => n.code === "SUBSETTED")) && this.setCacheEntry(this.fhirUrl(t.resourceType, t.id).toString(), new k(Promise.resolve(t)));
  }
  deleteCacheEntry(t) {
    this.requestCache && this.requestCache.delete(t);
  }
  async request(t, n, i = {}, o = {}) {
    var _a, _b;
    await this.refreshIfExpired(), i.method = t, this.addFetchOptionsDefaults(i);
    let s = await this.fetchWithRetry(n, i);
    if (s.status === 401)
      return this.handleUnauthenticated(t, n, i);
    if (s.status === 204 || s.status === 304)
      return;
    let c = (_a = s.headers.get("content-type")) == null ? void 0 : _a.includes("json");
    if (s.status === 404 && !c)
      throw new d(Dr);
    let u = await this.parseBody(s, c), p = i.redirect ?? this.options.redirect;
    if ((s.status === 200 || s.status === 201) && p === "follow") {
      let v = await Kn(s, u);
      if (v)
        return this.request("GET", v, { ...i, body: void 0 });
    }
    let x = (_b = i.headers) == null ? void 0 : _b.Prefer;
    if (s.status === 202 && x === "respond-async") {
      let Cr = await Kn(s, u) ?? o.statusUrl;
      if (Cr)
        return this.pollStatus(Cr, i, o);
    }
    if (s.status >= 400)
      throw new d(Be(u));
    return u;
  }
  async parseBody(t, n) {
    let i;
    if (n)
      try {
        i = await t.json();
      } catch (o) {
        throw console.error("Error parsing response", t.status, o), o;
      }
    else
      i = await t.text();
    return i;
  }
  async fetchWithRetry(t, n) {
    t.startsWith("http") || (t = new URL(t, this.baseUrl).href);
    let i = 3, o = 200, s;
    for (let a = 0; a < i; a++) {
      try {
        if (this.options.verbose && this.logRequest(t, n), s = await this.fetch(t, n), this.options.verbose && this.logResponse(s), s.status < 500)
          return s;
      } catch (c) {
        this.retryCatch(a, i, c);
      }
      await rr(o);
    }
    return s;
  }
  logRequest(t, n) {
    if (console.log(`> ${n.method} ${t}`), n.headers) {
      let i = n.headers, o = Object.entries(i).sort((s, a) => s[0].localeCompare(a[0]));
      for (let [s, a] of o)
        console.log(`> ${s}: ${a}`);
    }
  }
  logResponse(t) {
    console.log(`< ${t.status} ${t.statusText}`), t.headers && t.headers.forEach((n, i) => console.log(`< ${i}: ${n}`));
  }
  async pollStatus(t, n, i) {
    return i.pollCount === void 0 ? (n.redirect = "follow", i.statusUrl = t, i.pollCount = 1) : (await rr(1e3), i.pollCount++), this.request("GET", t, n, i);
  }
  async executeAutoBatch() {
    var _a, _b;
    let t = [...this.autoBatchQueue];
    if (this.autoBatchQueue.length = 0, this.autoBatchTimerId = void 0, t.length === 1) {
      let o = t[0];
      try {
        o.resolve(await this.request(o.method, this.fhirBaseUrl + o.url, o.options));
      } catch (s) {
        o.reject(new d(Be(s)));
      }
      return;
    }
    let n = { resourceType: "Bundle", type: "batch", entry: t.map((o) => ({ request: { method: o.method, url: o.url }, resource: o.options.body ? JSON.parse(o.options.body) : void 0 })) }, i = await this.post(this.fhirBaseUrl.slice(0, -1), n);
    for (let o = 0; o < t.length; o++) {
      let s = t[o], a = (_a = i.entry) == null ? void 0 : _a[o];
      ((_b = a == null ? void 0 : a.response) == null ? void 0 : _b.outcome) && !Mt(a.response.outcome) ? s.reject(new d(a.response.outcome)) : s.resolve(a == null ? void 0 : a.resource);
    }
  }
  addFetchOptionsDefaults(t) {
    let n = t.headers;
    n || (n = {}, t.headers = n), n.Accept || (n.Accept = is), n["X-Medplum"] = "extended", t.body && !n["Content-Type"] && (n["Content-Type"] = M.FHIR_JSON), this.accessToken ? n.Authorization = "Bearer " + this.accessToken : this.basicAuth && (n.Authorization = "Basic " + this.basicAuth), t.cache || (t.cache = "no-cache"), t.credentials || (t.credentials = "include");
  }
  setRequestContentType(t, n) {
    t.headers || (t.headers = {});
    let i = t.headers;
    i["Content-Type"] = n;
  }
  setRequestBody(t, n) {
    typeof n == "string" || typeof Blob < "u" && (n instanceof Blob || n.constructor.name === "Blob") || typeof File < "u" && (n instanceof File || n.constructor.name === "File") || typeof Uint8Array < "u" && (n instanceof Uint8Array || n.constructor.name === "Uint8Array") ? t.body = n : n && (t.body = JSON.stringify(n));
  }
  handleUnauthenticated(t, n, i) {
    return this.refresh() ? this.request(t, n, i) : (this.clearActiveLogin(), this.onUnauthenticated && this.onUnauthenticated(), Promise.reject(new Error("Unauthenticated")));
  }
  async startPkce() {
    let t = pr();
    sessionStorage.setItem("pkceState", t);
    let n = pr();
    sessionStorage.setItem("codeVerifier", n);
    let i = await Mn(n), o = mn(i).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
    return sessionStorage.setItem("codeChallenge", o), { codeChallengeMethod: "S256", codeChallenge: o };
  }
  async requestAuthorization(t) {
    let n = await this.ensureCodeChallenge(t ?? {}), i = new URL(this.authorizeUrl);
    i.searchParams.set("response_type", "code"), i.searchParams.set("state", sessionStorage.getItem("pkceState")), i.searchParams.set("client_id", n.clientId ?? this.clientId), i.searchParams.set("redirect_uri", n.redirectUri ?? Hn()), i.searchParams.set("code_challenge_method", n.codeChallengeMethod), i.searchParams.set("code_challenge", n.codeChallenge), i.searchParams.set("scope", n.scope ?? "openid profile"), window.location.assign(i.toString());
  }
  processCode(t, n) {
    let i = new URLSearchParams();
    if (i.set("grant_type", "authorization_code"), i.set("code", t), i.set("client_id", (n == null ? void 0 : n.clientId) ?? this.clientId), i.set("redirect_uri", (n == null ? void 0 : n.redirectUri) ?? Hn()), typeof sessionStorage < "u") {
      let o = sessionStorage.getItem("codeVerifier");
      o && i.set("code_verifier", o);
    }
    return this.fetchTokens(i);
  }
  refreshIfExpired() {
    return !this.refreshPromise && this.accessTokenExpires !== void 0 && this.accessTokenExpires < Date.now() && this.refresh(), this.refreshPromise ?? Promise.resolve();
  }
  refresh() {
    if (this.refreshPromise)
      return this.refreshPromise;
    if (this.refreshToken) {
      let t = new URLSearchParams();
      return t.set("grant_type", "refresh_token"), t.set("client_id", this.clientId), t.set("refresh_token", this.refreshToken), this.refreshPromise = this.fetchTokens(t), this.refreshPromise;
    }
    if (this.clientId && this.clientSecret)
      return this.refreshPromise = this.startClientLogin(this.clientId, this.clientSecret), this.refreshPromise;
  }
  async startClientLogin(t, n) {
    this.clientId = t, this.clientSecret = n;
    let i = new URLSearchParams();
    return i.set("grant_type", "client_credentials"), i.set("client_id", t), i.set("client_secret", n), this.fetchTokens(i);
  }
  async startJwtBearerLogin(t, n, i) {
    this.clientId = t;
    let o = new URLSearchParams();
    return o.set("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer"), o.set("client_id", t), o.set("assertion", n), o.set("scope", i), this.fetchTokens(o);
  }
  async startJwtAssertionLogin(t) {
    let n = new URLSearchParams();
    return n.append("grant_type", "client_credentials"), n.append("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"), n.append("client_assertion", t), this.fetchTokens(n);
  }
  setBasicAuth(t, n) {
    this.clientId = t, this.clientSecret = n, this.basicAuth = Dn(t + ":" + n);
  }
  async fhircastSubscribe(t, n) {
    if (!(typeof t == "string" && t !== ""))
      throw new d(m("Invalid topic provided. Topic must be a valid string."));
    if (!(typeof n == "object" && Array.isArray(n) && n.length > 0))
      throw new d(m("Invalid events provided. Events must be an array of event names containing at least one event."));
    let i = { channelType: "websocket", mode: "subscribe", topic: t, events: n }, s = (await this.post("/fhircast/STU3", mr(i), M.FORM_URL_ENCODED))["hub.channel.endpoint"];
    if (!s)
      throw new Error("Invalid response!");
    return i.endpoint = s, i;
  }
  async fhircastUnsubscribe(t) {
    if (!yt(t))
      throw new d(m("Invalid topic or subscriptionRequest. SubscriptionRequest must be an object."));
    if (!(t.endpoint && typeof t.endpoint == "string" && t.endpoint.startsWith("ws")))
      throw new d(m("Provided subscription request must have an endpoint in order to unsubscribe."));
    t.mode = "unsubscribe", await this.post("/fhircast/STU3", mr(t), M.FORM_URL_ENCODED);
  }
  fhircastConnect(t) {
    return new ht(t);
  }
  async fhircastPublish(t, n, i, o) {
    return _n(n) ? this.post(`/fhircast/STU3/${t}`, hr(t, n, i, o), M.JSON) : (Un(n), this.post(`/fhircast/STU3/${t}`, hr(t, n, i), M.JSON));
  }
  async fhircastGetContext(t) {
    return this.get(`/fhircast/STU3/${t}`);
  }
  async invite(t, n) {
    return this.post("admin/projects/" + t + "/invite", n);
  }
  async fetchTokens(t) {
    let n = { method: "POST", headers: { "Content-Type": M.FORM_URL_ENCODED }, body: t.toString(), credentials: "include" }, i = n.headers;
    this.basicAuth && (i.Authorization = `Basic ${this.basicAuth}`);
    let o;
    try {
      o = await this.fetchWithRetry(this.tokenUrl, n);
    } catch (a) {
      throw this.refreshPromise = void 0, a;
    }
    if (!o.ok) {
      this.clearActiveLogin();
      try {
        let a = await o.json();
        throw new d(b(a.error_description));
      } catch (a) {
        throw new d(b("Failed to fetch tokens"), a);
      }
    }
    let s = await o.json();
    return await this.verifyTokens(s), this.getProfile();
  }
  async verifyTokens(t) {
    let n = t.access_token;
    if (Bn(n)) {
      let i = gt(n);
      if (Date.now() >= i.exp * 1e3)
        throw this.clearActiveLogin(), new Error("Token expired");
      if (i.cid) {
        if (i.cid !== this.clientId)
          throw this.clearActiveLogin(), new Error("Token was not issued for this audience");
      } else if (this.clientId && i.client_id !== this.clientId)
        throw this.clearActiveLogin(), new Error("Token was not issued for this audience");
    }
    return this.setActiveLogin({ accessToken: n, refreshToken: t.refresh_token, project: t.project, profile: t.profile });
  }
  setupStorageListener() {
    try {
      window.addEventListener("storage", (t) => {
        (t.key === null || t.key === "activeLogin") && window.location.reload();
      });
    } catch {
    }
  }
  retryCatch(t, n, i) {
    if (i.message === "Failed to fetch" && t === 1 && this.dispatchEvent({ type: "offline" }), t >= n - 1)
      throw i;
  }
  getSubscriptionManager() {
    return this.subscriptionManager || (this.subscriptionManager = new xt(this, gn("/ws/subscriptions-r4", this.baseUrl))), this.subscriptionManager;
  }
  subscribeToCriteria(t) {
    return this.getSubscriptionManager().addCriteria(t);
  }
  unsubscribeFromCriteria(t) {
    this.subscriptionManager && (this.subscriptionManager.removeCriteria(t), this.subscriptionManager.getCriteriaCount() === 0 && this.subscriptionManager.closeWebSocket());
  }
  getMasterSubscriptionEmitter() {
    return this.getSubscriptionManager().getMasterEmitter();
  }
};
function fs() {
  if (!globalThis.fetch)
    throw new Error("Fetch not available in this environment");
  return globalThis.fetch.bind(globalThis);
}
function Hn() {
  return typeof window > "u" ? "" : window.location.protocol + "//" + window.location.host + "/";
}
function Wn(r4) {
  return r4.endsWith("/") ? r4 : r4 + "/";
}
function St(r4, e) {
  return new URL(e, r4).toString();
}
async function Kn(r4, e) {
  var _a, _b;
  let t = r4.headers.get("content-location");
  if (t)
    return t;
  let n = r4.headers.get("location");
  if (n)
    return n;
  if (ce(e) && ((_b = (_a = e.issue) == null ? void 0 : _a[0]) == null ? void 0 : _b.diagnostics))
    return e.issue[0].diagnostics;
}
function vr(r4) {
  var _a;
  let e = ((_a = r4.entry) == null ? void 0 : _a.map((t) => t.resource)) ?? [];
  return Object.assign(e, { bundle: r4 });
}
var up = { aws_ssm_parameter_store: "aws_ssm_parameter_store" };
function Tr({ parentContext: r4, path: e, elements: t, profileUrl: n, debugMode: i }) {
  if (e === (r4 == null ? void 0 : r4.path))
    return;
  let o = ms(e, t, r4, !!i), s = /* @__PURE__ */ Object.create(null);
  for (let [a, c] of Object.entries(o))
    s[e + "." + a] = c;
  return { path: e, elements: o, elementsByPath: s, profileUrl: n ?? (r4 == null ? void 0 : r4.profileUrl), debugMode: i ?? (r4 == null ? void 0 : r4.debugMode) ?? false };
}
function ms(r4, e, t, n) {
  let i = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let [s, a] of Object.entries(t.elementsByPath)) {
      let c = de(r4, s);
      c !== void 0 && (i[c] = a);
    }
  let o = false;
  if (e)
    for (let [s, a] of Object.entries(e))
      s in i || (i[s] = a, o = true);
  return n && console.assert(o, "Unnecessary ElementsContext; not using any newly provided elements"), i;
}
function zn(r4) {
  return r4.type !== void 0 && r4.type.length > 0;
}
function hs(r4, e, t, n) {
  var _a;
  let i = Re(r4, e.path, { profileUrl: n });
  if (i) {
    let o = ((_a = t.typeSchema) == null ? void 0 : _a.elements) ?? t.elements;
    return i.some((s) => zt(s, e, t, o)) ?? false;
  }
  return console.assert(false, "getNestedProperty[%s] in isDiscriminatorComponentMatch missed", e.path), false;
}
function Jn(r4, e, t, n) {
  var _a, _b;
  if (r4)
    for (let i of e) {
      let o = { value: r4, type: ((_a = i.typeSchema) == null ? void 0 : _a.name) ?? ((_b = i.type) == null ? void 0 : _b[0].code) };
      if (t.every((s) => {
        var _a2;
        return hs(o, s, i, ((_a2 = i.typeSchema) == null ? void 0 : _a2.url) ?? n);
      }))
        return i.name;
    }
}
var ve = class {
  constructor(e, t, n) {
    if (e.type === void 0)
      throw new Error("schema must include a type");
    this.rootSchema = e;
    let i = Tr({ parentContext: void 0, path: this.rootSchema.type, elements: n ?? this.rootSchema.elements, profileUrl: this.rootSchema.name === this.rootSchema.type ? void 0 : this.rootSchema.url });
    if (i === void 0)
      throw new Error("Could not create root elements context");
    this.elementsContextStack = [i], this.visitor = t;
  }
  get elementsContext() {
    return this.elementsContextStack[this.elementsContextStack.length - 1];
  }
  crawlElement(e, t, n) {
    this.visitor.onEnterSchema && this.visitor.onEnterSchema(this.rootSchema);
    let i = Object.fromEntries(Object.entries(this.elementsContext.elements).filter(([o]) => o.startsWith(t)));
    this.crawlElementsImpl(i, n), this.visitor.onExitSchema && this.visitor.onExitSchema(this.rootSchema);
  }
  crawlSlice(e, t, n) {
    let i = this.prepareSlices(n.slices, n);
    if (!G(i.slices))
      throw new Error(`cannot crawl slice ${t.name} since it has no type information`);
    this.visitor.onEnterSchema && this.visitor.onEnterSchema(this.rootSchema), this.sliceAllowList = [t], this.crawlSliceImpl(i.slices[0], t.path, i), this.sliceAllowList = void 0, this.visitor.onExitSchema && this.visitor.onExitSchema(this.rootSchema);
  }
  crawlResource() {
    this.visitor.onEnterSchema && this.visitor.onEnterSchema(this.rootSchema), this.crawlElementsImpl(this.rootSchema.elements, this.rootSchema.type), this.visitor.onExitSchema && this.visitor.onExitSchema(this.rootSchema);
  }
  crawlElementsImpl(e, t) {
    let n = ys(e);
    for (let i of n)
      this.crawlElementNode(i, t);
  }
  crawlElementNode(e, t) {
    var _a, _b;
    let n = t + "." + e.key;
    this.visitor.onEnterElement && this.visitor.onEnterElement(n, e.element, this.elementsContext);
    for (let i of e.children)
      this.crawlElementNode(i, t);
    G((_b = (_a = e.element) == null ? void 0 : _a.slicing) == null ? void 0 : _b.slices) && this.crawlSlicingImpl(e.element.slicing, n), this.visitor.onExitElement && this.visitor.onExitElement(n, e.element, this.elementsContext);
  }
  prepareSlices(e, t) {
    var _a, _b;
    let n = [];
    for (let o of e) {
      if (!zn(o))
        continue;
      let s = (_b = (_a = o.type.find((a) => G(a.profile))) == null ? void 0 : _a.profile) == null ? void 0 : _b[0];
      if (G(s)) {
        let a = Kr(s);
        a && (o.typeSchema = a);
      }
      n.push(o);
    }
    return { ...t, slices: n };
  }
  crawlSlicingImpl(e, t) {
    let n = this.prepareSlices(e.slices, e);
    for (let i of n.slices)
      (this.sliceAllowList === void 0 || this.sliceAllowList.includes(i)) && this.crawlSliceImpl(i, t, n);
  }
  crawlSliceImpl(e, t, n) {
    let i = e.typeSchema;
    i && this.visitor.onEnterSchema && this.visitor.onEnterSchema(i), this.visitor.onEnterSlice && this.visitor.onEnterSlice(t, e, n);
    let o, s = (i == null ? void 0 : i.elements) ?? e.elements;
    G(s) && (o = Tr({ path: t, parentContext: this.elementsContext, elements: s })), o && this.elementsContextStack.push(o), this.crawlElementsImpl(s, t), o && this.elementsContextStack.pop(), this.visitor.onExitSlice && this.visitor.onExitSlice(t, e, n), i && this.visitor.onExitSchema && this.visitor.onExitSchema(i);
  }
};
function ys(r4) {
  let e = [];
  function t(o, s) {
    return s.startsWith(o + ".");
  }
  function n(o, s) {
    for (let a of o.children)
      if (t(a.key, s.key)) {
        n(a, s);
        return;
      }
    o.children.push(s);
  }
  let i = Object.entries(r4);
  i.sort((o, s) => o[0].localeCompare(s[0]));
  for (let [o, s] of i) {
    let a = { key: o, element: s, children: [] }, c = false;
    for (let u of e)
      if (t(u.key, o)) {
        n(u, a), c = true;
        break;
      }
    c || e.push(a);
  }
  return e;
}
var Et = "__sliceName";
function Dp(r4, e) {
  let t = new De(r4, r4.resourceType, "resource");
  return new ve(e, t).crawlResource(), t.getDefaultValue();
}
function Mp(r4, e, t) {
  for (let [n, i] of Object.entries(e)) {
    if (t === void 0 || t === n) {
      Ct(r4, n, i, e);
      continue;
    }
    let o = de(t, n);
    o !== void 0 && Ct(r4, o, i, e);
  }
  return r4;
}
function Np(r4, e, t, n, i) {
  let o = r4 ?? /* @__PURE__ */ Object.create(null), [s, a] = xs(e, "."), c = /* @__PURE__ */ Object.create(null);
  bt(c, o, a, t);
  let u = new De(c, s, "element");
  new ve(i, u, n).crawlElement(t, a, s);
  let x = u.getDefaultValue();
  return Rt(x, a, t, n);
}
function Fp(r4, e, t, n) {
  let i = new De([{ [Et]: e.name }], e.path, "element");
  return new ve(n, i).crawlSlice(r4, e, t), i.getDefaultValue()[0];
}
var De = class {
  constructor(e, t, n) {
    this.schemaStack = [], this.valueStack = [], this.rootValue = ee(e), this.valueStack.splice(0, this.valueStack.length, { type: n, path: t, values: [this.rootValue] });
  }
  get schema() {
    return this.schemaStack[this.schemaStack.length - 1];
  }
  get value() {
    return this.valueStack[this.valueStack.length - 1];
  }
  onEnterSchema(e) {
    this.schemaStack.push(e);
  }
  onExitSchema() {
    this.schemaStack.pop();
  }
  onEnterElement(e, t, n) {
    let i = this.value.values, o = this.value.path, s = de(o, e);
    if (s === void 0)
      throw new Error(`Expected ${e} to be prefixed by ${o}`);
    let a = [];
    for (let c of i) {
      if (c === void 0)
        continue;
      let u = Array.isArray(c) ? c : [c];
      for (let p of u) {
        gs(p, s, t, n.elements), Ct(p, s, t, n.elements);
        let x = Rt(p, s, t, n.elements);
        x !== void 0 && a.push(x);
      }
    }
    this.valueStack.push({ type: "element", path: e, values: a });
  }
  onExitElement(e, t, n) {
    if (!this.valueStack.pop())
      throw new Error("Expected value context to exist when exiting element");
    let o = de(this.value.path, e);
    if (o === void 0)
      throw new Error(`Expected ${e} to be prefixed by ${this.value.path}`);
    for (let s of this.value.values) {
      let a = Rt(s, o, t, n.elements);
      if (Array.isArray(a))
        for (let c = a.length - 1; c >= 0; c--) {
          let u = a[c];
          G(u) || a.splice(c, 1);
        }
      S(a) && bt(s, void 0, o, t);
    }
  }
  onEnterSlice(e, t, n) {
    let i = this.value.values, o = [];
    for (let s of i) {
      if (s === void 0)
        continue;
      if (!Array.isArray(s))
        throw new Error("Expected array value for sliced element");
      let a = this.getMatchingSliceValues(s, t, n);
      o.push(a);
    }
    this.valueStack.push({ type: "slice", path: e, values: o });
  }
  getMatchingSliceValues(e, t, n) {
    let i = [];
    for (let o of e)
      (o[Et] ?? Jn(o, [t], n.discriminator, this.schema.url)) === t.name && i.push(o);
    for (let o = i.length; o < t.min; o++)
      if (tr(t.type[0].code)) {
        let s = /* @__PURE__ */ Object.create(null);
        i.push(s), e.push(s);
      }
    return i;
  }
  onExitSlice() {
    let e = this.valueStack.pop();
    if (!e)
      throw new Error("Expected value context to exist in onExitSlice");
    for (let t of e.values)
      for (let n = t.length - 1; n >= 0; n--) {
        let i = t[n];
        Et in i && delete i[Et];
      }
  }
  getDefaultValue() {
    return this.rootValue;
  }
};
function gs(r4, e, t, n) {
  let i = Rt(r4, e, t, n);
  t.min > 0 && i === void 0 && tr(t.type[0].code) && (t.isArray ? bt(r4, [/* @__PURE__ */ Object.create(null)], e, t) : bt(r4, /* @__PURE__ */ Object.create(null), e, t));
}
function bt(r4, e, t, n) {
  if (t.includes("."))
    throw new Error("key cannot be nested");
  let i = t;
  if (t.includes("[x]")) {
    let o = n.type[0].code;
    i = t.replace("[x]", C(o));
  }
  e === void 0 ? delete r4[i] : r4[i] = e;
}
function Rt(r4, e, t, n) {
  let i = e.split("."), o = r4, s;
  for (let a = 0; a < i.length; a++) {
    let c = i[a];
    if (c.includes("[x]")) {
      let p = n[i.slice(0, a + 1).join(".")].type[0].code;
      c = c.replace("[x]", C(p));
    }
    if (a === i.length - 1) {
      Array.isArray(o) ? s = o.map((u) => u[c]) : s = o[c];
      continue;
    }
    if (Array.isArray(o))
      o = o.map((u) => u[c]);
    else if (O(o)) {
      if (o[c] === void 0)
        return;
      o = o[c];
    } else
      return;
  }
  return s;
}
function Ct(r4, e, t, n) {
  if (!(t.fixed || t.pattern))
    return r4;
  if (Array.isArray(r4))
    return r4.map((a) => Ct(a, e, t, n));
  r4 == null && (r4 = /* @__PURE__ */ Object.create(null));
  let i = r4, o = e.split("."), s = i;
  for (let a = 0; a < o.length; a++) {
    let c = o[a];
    if (c.includes("[x]")) {
      let p = n[o.slice(0, a + 1).join(".")].type[0].code;
      c = c.replace("[x]", C(p));
    }
    if (a === o.length - 1) {
      let u = Array.isArray(s) ? s : [s];
      for (let p of u)
        t.fixed ? p[c] ?? (p[c] = t.fixed.value) : t.pattern && (p[c] = Yn(p[c], t.pattern.value));
    } else {
      if (!(c in s)) {
        let u = o.slice(0, a + 1).join(".");
        s[c] = n[u].isArray ? [/* @__PURE__ */ Object.create(null)] : /* @__PURE__ */ Object.create(null);
      }
      s = s[c];
    }
  }
  return i;
}
function Yn(r4, e) {
  if (Array.isArray(e) && (Array.isArray(r4) || r4 === void 0))
    return ((r4 == null ? void 0 : r4.length) ?? 0) > 0 ? r4 : ee(e);
  if (O(e) && (O(r4) && !Array.isArray(r4) || r4 === void 0)) {
    let t = ee(r4) ?? /* @__PURE__ */ Object.create(null);
    for (let n of Object.keys(e))
      t[n] = Yn(t[n], e[n]);
    return t;
  }
  return r4;
}
function xs(r4, e) {
  let t = r4.lastIndexOf(e);
  if (t === -1)
    return ["", r4];
  let n = r4.substring(0, t), i = r4.substring(t + e.length);
  return [n, i];
}
function Zn(r4, e) {
  if (!r4.group)
    throw new d(b("ConceptMap does not specify a mapping group", "ConceptMap.group"));
  let t = vs(e);
  if (ce(t))
    throw new d(t);
  let n = Ss(t, e.targetsystem ? r4.group.filter((o) => o.target === e.targetsystem) : r4.group), i = n.length > 0;
  return { result: i, match: i ? n : void 0 };
}
function vs(r4) {
  return r4.code && !r4.coding && !r4.codeableConcept ? r4.system === void 0 ? b("Missing required 'system' input parameter with 'code' parameter") : { [r4.system]: [r4.code] } : r4.coding && !r4.code && !r4.codeableConcept ? { [r4.coding.system ?? ""]: [r4.coding.code ?? ""] } : r4.codeableConcept && !r4.code && !r4.coding ? Ts(r4.codeableConcept) : r4.code || r4.coding || r4.codeableConcept ? b("Ambiguous input: multiple source codings provided") : b("No source provided: 'code'+'system', 'coding', or 'codeableConcept' input parameter is required");
}
function Ts(r4) {
  var _a;
  let e = /* @__PURE__ */ Object.create(null);
  if (!((_a = r4.coding) == null ? void 0 : _a.length))
    return e;
  for (let { system: t, code: n } of r4.coding) {
    if (!n)
      continue;
    let i = t ?? "";
    e[i] = e[i] ? [...e[i], n] : [n];
  }
  return e;
}
function Ss(r4, e) {
  var _a;
  let t = [];
  for (let [n, i] of Object.entries(r4))
    for (let o of e.filter((s) => (s.source ?? "") === n)) {
      let s = (_a = o.element) == null ? void 0 : _a.filter((a) => i.includes(a.code)).flatMap((a) => {
        var _a2;
        return ((_a2 = a.target) == null ? void 0 : _a2.map((c) => ({ equivalence: c.equivalence, concept: { system: o.target, code: c.code, display: c.display } }))) ?? [];
      });
      (s == null ? void 0 : s.length) || (s = Es(i, o)), s && t.push(...s);
    }
  return t;
}
function Es(r4, e) {
  var _a;
  switch ((_a = e.unmapped) == null ? void 0 : _a.mode) {
    case "provided":
      return r4.map((t) => ({ equivalence: "equal", concept: { system: e.target, code: t } }));
    case "fixed":
      return [{ equivalence: "equivalent", concept: { system: e.target, code: e.unmapped.code, display: e.unmapped.display } }];
    default:
      return;
  }
}
var bs = [...we, "->", "<<", ">>", "=="];
function Xn(r4) {
  return new K(r4, Pe, bs).tokenize();
}
var Rs = { "-": "disjoint", "==": "equal" };
var Sr = class {
  constructor(e) {
    this.parser = e;
    this.structureMap = { resourceType: "StructureMap", status: "active" };
  }
  parse() {
    var _a;
    for (; this.parser.hasMore(); ) {
      let e = (_a = this.parser.peek()) == null ? void 0 : _a.value;
      switch (e) {
        case "map":
          this.parseMap();
          break;
        case "uses":
          this.parseUses();
          break;
        case "imports":
          this.parseImport();
          break;
        case "group":
          this.parseGroup();
          break;
        case "conceptmap":
          this.parseConceptMap();
          break;
        default:
          throw new Error(`Unexpected token: ${e}`);
      }
    }
    return this.structureMap;
  }
  parseMap() {
    this.parser.consume("Symbol", "map"), this.structureMap.url = this.parser.consume("String").value, this.parser.consume("="), this.structureMap.name = this.parser.consume().value;
  }
  parseUses() {
    var _a;
    this.parser.consume("Symbol", "uses");
    let e = {};
    e.url = this.parser.consume("String").value, ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "alias" && (this.parser.consume("Symbol", "alias"), e.alias = this.parser.consume("Symbol").value), this.parser.consume("Symbol", "as"), e.mode = this.parser.consume().value, this.structureMap.structure || (this.structureMap.structure = []), this.structureMap.structure.push(e);
  }
  parseImport() {
    this.parser.consume("Symbol", "imports"), this.structureMap.import || (this.structureMap.import = []), this.structureMap.import.push(this.parser.consume("String").value);
  }
  parseGroup() {
    var _a, _b, _c2;
    let e = {};
    this.parser.consume("Symbol", "group"), e.name = this.parser.consume("Symbol").value, e.input = this.parseParameters(), ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "extends" && (this.parser.consume("Symbol", "extends"), e.extends = this.parser.consume("Symbol").value), ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "<<" ? (this.parser.consume("<<"), e.typeMode = this.parser.consume().value, ((_c2 = this.parser.peek()) == null ? void 0 : _c2.value) === "+" && (this.parser.consume("+"), e.typeMode = "type-and-types"), this.parser.consume(">>")) : e.typeMode = "none", e.rule = this.parseRules(), this.structureMap.group || (this.structureMap.group = []), this.structureMap.group.push(e);
  }
  parseParameters() {
    var _a, _b;
    let e = [];
    for (this.parser.consume("("); this.parser.hasMore() && ((_a = this.parser.peek()) == null ? void 0 : _a.value) !== ")"; )
      e.push(this.parseParameter()), ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "," && this.parser.consume(",");
    return this.parser.consume(")"), e;
  }
  parseParameter() {
    var _a;
    let e = {};
    return e.mode = this.parser.consume().value, e.name = this.parser.consume("Symbol").value, ((_a = this.parser.peek()) == null ? void 0 : _a.value) === ":" && (this.parser.consume(":"), e.type = this.parser.consume("Symbol").value), e;
  }
  parseRules() {
    var _a;
    let e = [];
    for (this.parser.consume("{"); this.parser.hasMore() && ((_a = this.parser.peek()) == null ? void 0 : _a.value) !== "}"; )
      e.push(this.parseRule());
    return this.parser.consume("}"), e;
  }
  parseRule() {
    var _a, _b, _c2, _d, _e2, _f;
    let e = { source: this.parseRuleSources() };
    return ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "->" && (this.parser.consume("->"), e.target = this.parseRuleTargets()), ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "then" && (this.parser.consume("Symbol", "then"), ((_c2 = this.parser.peek()) == null ? void 0 : _c2.id) === "{" ? e.rule = this.parseRules() : e.dependent = this.parseRuleDependents()), ((_d = this.parser.peek()) == null ? void 0 : _d.id) === "String" ? e.name = this.parser.consume().value : e.name = (_f = (_e2 = e.source) == null ? void 0 : _e2[0]) == null ? void 0 : _f.element, this.parser.consume(";"), e;
  }
  parseRuleSources() {
    var _a, _b;
    this.parser.hasMore() && ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "for" && this.parser.consume("Symbol", "for");
    let e = [this.parseRuleSource()];
    for (; this.parser.hasMore() && ((_b = this.parser.peek()) == null ? void 0 : _b.value) === ","; )
      this.parser.consume(","), e.push(this.parseRuleSource());
    return e;
  }
  parseRuleSource() {
    var _a, _b, _c2, _d, _e2, _f, _g, _h, _i2, _j, _k;
    let e = {}, n = this.parseRuleContext().split(".");
    if (e.context = n[0], e.element = n[1], this.parser.hasMore() && ((_a = this.parser.peek()) == null ? void 0 : _a.value) === ":" && (this.parser.consume(":"), e.type = this.parser.consume().value), this.parser.hasMore() && ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "default" && (this.parser.consume("Symbol", "default"), e.defaultValueString = this.parser.consume("String").value), (((_c2 = this.parser.peek()) == null ? void 0 : _c2.value) === "first" || ((_d = this.parser.peek()) == null ? void 0 : _d.value) === "not_first" || ((_e2 = this.parser.peek()) == null ? void 0 : _e2.value) === "last" || ((_f = this.parser.peek()) == null ? void 0 : _f.value) === "not_last" || ((_g = this.parser.peek()) == null ? void 0 : _g.value) === "only_one") && (e.listMode = this.parser.consume().value), ((_h = this.parser.peek()) == null ? void 0 : _h.value) === "as" && (this.parser.consume("Symbol", "as"), e.variable = this.parser.consume().value), ((_i2 = this.parser.peek()) == null ? void 0 : _i2.value) === "log" && (this.parser.consume("Symbol", "log"), e.logMessage = this.parser.consume().value), ((_j = this.parser.peek()) == null ? void 0 : _j.value) === "where") {
      this.parser.consume("Symbol", "where");
      let i = this.parser.consumeAndParse(h.Arrow);
      e.condition = i.toString();
    }
    if (((_k = this.parser.peek()) == null ? void 0 : _k.value) === "check") {
      this.parser.consume("Symbol", "check");
      let i = this.parser.consumeAndParse(h.Arrow);
      e.check = i.toString();
    }
    return e;
  }
  parseRuleTargets() {
    var _a;
    let e = [this.parseRuleTarget()];
    for (; this.parser.hasMore() && ((_a = this.parser.peek()) == null ? void 0 : _a.value) === ","; )
      this.parser.consume(","), e.push(this.parseRuleTarget());
    return e;
  }
  parseRuleTarget() {
    var _a, _b, _c2, _d, _e2, _f;
    let e = {}, n = this.parseRuleContext().split(".");
    return e.contextType = "variable", e.context = n[0], e.element = n[1], ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "=" && (this.parser.consume("="), this.parseRuleTargetTransform(e)), ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "as" && (this.parser.consume("Symbol", "as"), e.variable = this.parser.consume().value), ((_c2 = this.parser.peek()) == null ? void 0 : _c2.value) === "share" && (this.parser.consume("Symbol", "share"), e.listMode = ["share"], this.parser.consume("Symbol")), (((_d = this.parser.peek()) == null ? void 0 : _d.value) === "first" || ((_e2 = this.parser.peek()) == null ? void 0 : _e2.value) === "last" || ((_f = this.parser.peek()) == null ? void 0 : _f.value) === "collate") && (e.listMode = [this.parser.consume().value]), e;
  }
  parseRuleTargetTransform(e) {
    var _a;
    let t = this.parser.consumeAndParse(h.As);
    t instanceof Q ? (e.transform = t.name, e.parameter = (_a = t.args) == null ? void 0 : _a.map(ei)) : t instanceof D || t instanceof j ? (e.transform = "copy", e.parameter = [ei(t)]) : (e.transform = "evaluate", e.parameter = [{ valueString: t.toString() }]);
  }
  parseRuleContext() {
    var _a;
    let e = this.parser.consume().value;
    for (; ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "."; )
      this.parser.consume("."), e += "." + this.parser.consume().value;
    return e;
  }
  parseRuleDependents() {
    let e = this.parser.consumeAndParse(h.Arrow);
    return [{ name: e.name, variable: e.args.map((t) => t.name) }];
  }
  parseConceptMap() {
    var _a, _b;
    this.parser.consume("Symbol", "conceptmap");
    let e = { resourceType: "ConceptMap", status: "active" };
    e.url = this.parser.consume("String").value, this.parser.consume("{");
    let t = {}, n = (_a = this.parser.peek()) == null ? void 0 : _a.value;
    for (; n !== "}"; )
      n === "prefix" ? this.parseConceptMapPrefix(t) : this.parseConceptMapRule(e, t), n = (_b = this.parser.peek()) == null ? void 0 : _b.value;
    this.parser.consume("}"), this.structureMap.contained || (this.structureMap.contained = []), this.structureMap.contained.push(e);
  }
  parseConceptMapPrefix(e) {
    this.parser.consume("Symbol", "prefix");
    let t = this.parser.consume().value;
    this.parser.consume("=");
    let n = this.parser.consume().value;
    e[t] = n;
  }
  parseConceptMapRule(e, t) {
    var _a;
    let n = this.parser.consume().value, i = t[n];
    this.parser.consume(":");
    let o = this.parser.consume().value, s = Rs[this.parser.consume().value], a = this.parser.consume().value, c = t[a];
    this.parser.consume(":");
    let u = this.parser.consume().value, p = (_a = e == null ? void 0 : e.group) == null ? void 0 : _a.find((x) => x.source === i && x.target === c);
    p || (p = { source: i, target: c, element: [] }, e.group || (e.group = []), e.group.push(p)), p.element || (p.element = []), p.element.push({ code: o, target: [{ code: u, equivalence: s }] });
  }
};
function ei(r4) {
  if (r4 instanceof j)
    return { valueId: r4.name };
  if (r4 instanceof D)
    return Cs(r4);
  throw new Error(`Unknown parameter atom type: ${r4.constructor.name} (${r4.toString()})`);
}
function Cs(r4) {
  switch (r4.value.type) {
    case "boolean":
      return { valueBoolean: r4.value.value };
    case "decimal":
      return { valueDecimal: r4.value.value };
    case "integer":
      return { valueInteger: r4.value.value };
    case "dateTime":
    case "string":
      return { valueString: r4.value.value };
    default:
      throw new Error("Unknown target literal type: " + r4.value.type);
  }
}
var Ps = Ae().registerInfix("->", { precedence: h.Arrow }).registerInfix(";", { precedence: h.Semicolon });
function Wp(r4) {
  let e = Ps.construct(Xn(r4));
  return e.removeComments(), new Sr(e).parse();
}
function ed(r4, e, t) {
  return ws({ root: r4, loader: t }, r4, e);
}
function ws(r4, e, t) {
  return As(r4, e), ni(r4, e), ii(r4, e.group[0], t);
}
function As(r4, e) {
  if (r4.loader && e.import)
    for (let t of e.import) {
      let n = r4.loader(t);
      for (let i of n)
        ni(r4, i);
    }
}
function ni(r4, e) {
  if (e.group)
    for (let t of e.group)
      Er(r4, t.name, { type: "StructureMapGroup", value: t });
}
function ii(r4, e, t) {
  let n = [], i = [];
  for (let u of e.input)
    u.mode === "source" && n.push(u), u.mode === "target" && i.push(u);
  if (n.length === 0)
    throw new Error("Missing source definitions");
  if (i.length === 0)
    throw new Error("Missing target definitions");
  if (t.length < n.length)
    throw new Error(`Not enough arguments (got ${t.length}, min ${n.length})`);
  if (t.length > n.length + i.length)
    throw new Error(`Too many arguments (got ${t.length}, max ${n.length + i.length})`);
  let o = {}, s = [], a = 0;
  for (let u of n)
    Me(o, u.name, t[a++]);
  for (let u of i) {
    let p = t[a++] ?? y({});
    Me(o, u.name, p), s.push(p);
  }
  let c = { root: r4.root, parent: r4, variables: o };
  if (e.rule)
    for (let u of e.rule)
      oi(c, u);
  return s;
}
function oi(r4, e) {
  e.source && si(r4, e, 0);
}
function si(r4, e, t) {
  let n = e.source[t];
  for (let i of ks(r4, n))
    n.variable && Er(r4, n.variable, i), t < e.source.length - 1 ? si(r4, e, t + 1) : Is(r4, e);
}
function Is(r4, e) {
  if (e.target)
    for (let t of e.target)
      Vs(r4, t);
  if (e.rule)
    for (let t of e.rule)
      oi(r4, t);
  if (e.dependent)
    for (let t of e.dependent)
      Bs(r4, t);
}
function ks(r4, e) {
  let t = Te(r4, e.context);
  if (!t)
    return [];
  let n = e.element;
  if (!n)
    return [t];
  let i = $(n, [t]);
  if (!i || i.length === 0)
    return [];
  if (e.condition && !ti(t, { [e.variable]: i[0] }, e.condition))
    return [];
  if (e.check && !ti(t, { [e.variable]: i[0] }, e.check))
    throw new Error("Check failed: " + e.check);
  return e.listMode && (i = Os(e, i)), i;
}
function ti(r4, e, t) {
  return N($(t, [r4], e));
}
function Os(r4, e) {
  switch (r4.listMode) {
    case "first":
      return [e[0]];
    case "not_first":
      return e.slice(1);
    case "last":
      return [e[e.length - 1]];
    case "not_last":
      return e.slice(0, e.length - 1);
    case "only_one":
      if (e.length !== 1)
        throw new Error("Expected only one value");
      break;
  }
  return e;
}
function Vs(r4, e) {
  let t = Te(r4, e.context);
  if (!t)
    throw new Error("Target not found: " + e.context);
  let n = t.value[e.element], i, o = Ds(t, e.element) || Array.isArray(n);
  if (!e.transform)
    o || n === void 0 ? i = [y({})] : i = [y(n)];
  else
    switch (e.transform) {
      case "append":
        i = Ms(r4, e);
        break;
      case "copy":
        i = Ns(r4, e);
        break;
      case "create":
        i = Fs(r4, e);
        break;
      case "evaluate":
        i = _s(r4, e);
        break;
      case "translate":
        i = Us(r4, e);
        break;
      case "truncate":
        i = Ls(r4, e);
        break;
      case "uuid":
        i = [{ type: "string", value: oe() }];
        break;
      default:
        throw new Error(`Unsupported transform: ${e.transform}`);
    }
  if (i.length !== 0) {
    if (o) {
      n || (n = [], Me(t.value, e.element, n));
      for (let s of i)
        n.push(s.value);
    } else
      Me(t.value, e.element, i[0].value);
    e.variable && Er(r4, e.variable, qs(i));
  }
}
function Ds(r4, e) {
  var _a, _b, _c2;
  return (_c2 = (_b = (_a = be(r4.type)) == null ? void 0 : _a.elements) == null ? void 0 : _b[e]) == null ? void 0 : _c2.isArray;
}
function Ms(r4, e) {
  var _a, _b, _c2, _d, _e2, _f;
  let t = (_c2 = (_b = z(r4, (_a = e.parameter) == null ? void 0 : _a[0])) == null ? void 0 : _b[0]) == null ? void 0 : _c2.value, n = (_f = (_e2 = z(r4, (_d = e.parameter) == null ? void 0 : _d[1])) == null ? void 0 : _e2[0]) == null ? void 0 : _f.value;
  return [{ type: "string", value: (t ?? "").toString() + (n ?? "").toString() }];
}
function Ns(r4, e) {
  return e.parameter.flatMap((t) => z(r4, t));
}
function Fs(r4, e) {
  var _a, _b, _c2;
  let t = {};
  return e.parameter && e.parameter.length > 0 && (t.resourceType = (_c2 = (_b = z(r4, (_a = e.parameter) == null ? void 0 : _a[0])) == null ? void 0 : _b[0]) == null ? void 0 : _c2.value), [y(t)];
}
function _s(r4, e) {
  var _a;
  let n = z(r4, (_a = e.parameter) == null ? void 0 : _a[0])[0].value;
  return $(n, [], ai(r4));
}
function Us(r4, e) {
  var _a, _b, _c2, _d, _e2, _f;
  let t = e.parameter.flatMap((a) => z(r4, a)), n = t[0].value, i = t[1].value, o = (_a = r4.root.contained) == null ? void 0 : _a.find((a) => a.resourceType === "ConceptMap" && a.url === i), s = Zn(o, { system: (_c2 = (_b = o.group) == null ? void 0 : _b[0]) == null ? void 0 : _c2.source, code: n });
  return [y((_f = (_e2 = (_d = s.match) == null ? void 0 : _d[0]) == null ? void 0 : _e2.concept) == null ? void 0 : _f.code)];
}
function Ls(r4, e) {
  var _a, _b, _c2, _d, _e2;
  let t = (_b = z(r4, (_a = e.parameter) == null ? void 0 : _a[0])) == null ? void 0 : _b[0], n = (_e2 = (_d = z(r4, (_c2 = e.parameter) == null ? void 0 : _c2[1])) == null ? void 0 : _d[0]) == null ? void 0 : _e2.value;
  return t.type === "string" ? [{ type: "string", value: t.value.substring(0, n) }] : [t];
}
function Bs(r4, e) {
  let t = Te(r4, e.name);
  if (!t)
    throw new Error("Dependent group not found: " + e.name);
  let n = e.variable, i = [];
  for (let s of n) {
    let a = Te(r4, s);
    if (!a)
      throw new Error("Dependent variable not found: " + s);
    i.push(a);
  }
  let o = { root: r4.root, parent: r4, variables: {} };
  ii(o, t.value, i);
}
function z(r4, e) {
  let n = P({ type: "StructureMapGroupRuleTargetParameter", value: e }, "value");
  if (!n)
    throw new Error("Missing target parameter: " + JSON.stringify(e));
  if (n = ri(n), n.length === 1 && n[0].type === "id") {
    let i = Te(r4, n[0].value);
    if (!i)
      throw new Error("Variable not found: " + n[0].value);
    return ri(i);
  }
  return n;
}
function Te(r4, e) {
  var _a;
  let t = (_a = r4.variables) == null ? void 0 : _a[e];
  if (t)
    return t;
  if (r4.parent)
    return Te(r4.parent, e);
}
function ai(r4, e = {}) {
  if (r4.parent && ai(r4.parent, e), r4.variables)
    for (let [t, n] of Object.entries(r4.variables))
      e[t] = n, e["%" + t] = n;
  return e;
}
function Er(r4, e, t) {
  r4.variables || (r4.variables = {}), Me(r4.variables, e, t);
}
function Me(r4, e, t) {
  if (e === "__proto__" || e === "constructor" || e === "prototype")
    throw new Error("Invalid key: " + e);
  r4[e] = t;
}
function ri(r4) {
  return Array.isArray(r4) ? r4 : [r4];
}
function qs(r4) {
  return r4.length === 1 ? r4[0] : r4;
}
var js = [...we, "eq", "ne", "co"];
function ci(r4) {
  return new K(r4, Pe, js, { dateTimeLiterals: true, symbolRegex: /[^\s\])]/ }).tokenize();
}
var Pt = class {
  constructor(e, t, n) {
    this.path = e;
    this.operator = t;
    this.value = n;
  }
};
var wt = class {
  constructor(e) {
    this.child = e;
  }
};
var At = class {
  constructor(e, t, n) {
    this.keyword = e;
    this.left = t;
    this.right = n;
  }
};
var $s = { eq: "eq", ne: "ne", co: "contains", sw: void 0, ew: void 0, gt: "gt", lt: "lt", ge: "ge", le: "le", ap: "ap", sa: "sa", eb: "eb", pr: "missing", po: void 0, ss: void 0, sb: void 0, in: "in", ni: "not-in", re: "eq", identifier: "identifier" };
function Gs(r4) {
  let e = $s[r4];
  if (!e)
    throw new d(b("Invalid operator: " + r4));
  return e;
}
var br = class {
  constructor(e) {
    this.parser = e;
  }
  parse() {
    var _a, _b, _c2;
    let e;
    ((_a = this.parser.peek()) == null ? void 0 : _a.value) === "(" ? (this.parser.consume("("), e = this.parse(), this.parser.consume(")")) : ((_b = this.parser.peek()) == null ? void 0 : _b.value) === "not" ? (this.parser.consume("Symbol", "not"), this.parser.consume("("), e = new wt(this.parse()), this.parser.consume(")")) : e = new Pt(this.parser.consume("Symbol").value, Gs(this.parser.consume("Symbol").value), this.parser.consume().value);
    let t = (_c2 = this.parser.peek()) == null ? void 0 : _c2.value;
    return t === "and" || t === "or" ? (this.parser.consume("Symbol", t), new At(t, e, this.parse())) : e;
  }
};
var Qs = Ae();
function dd(r4) {
  let e = Qs.construct(ci(r4));
  return e.removeComments(), new br(e).parse();
}
var J = class {
  constructor(e = "\r", t = "|", n = "^", i = "~", o = "\\", s = "&") {
    this.segmentSeparator = e;
    this.fieldSeparator = t;
    this.componentSeparator = n;
    this.repetitionSeparator = i;
    this.escapeCharacter = o;
    this.subcomponentSeparator = s;
  }
  getMsh1() {
    return this.fieldSeparator;
  }
  getMsh2() {
    return this.componentSeparator + this.repetitionSeparator + this.escapeCharacter + this.subcomponentSeparator;
  }
};
var ui = class r {
  constructor(e, t = new J()) {
    this.context = t, this.segments = e;
  }
  get header() {
    return this.segments[0];
  }
  get(e) {
    return this.getSegment(e);
  }
  getAll(e) {
    return this.getAllSegments(e);
  }
  getSegment(e) {
    return typeof e == "number" ? this.segments[e] : this.segments.find((t) => t.name === e);
  }
  getAllSegments(e) {
    return this.segments.filter((t) => t.name === e);
  }
  toString() {
    return this.segments.map((e) => e.toString()).join(this.context.segmentSeparator);
  }
  buildAck() {
    var _a, _b, _c2, _d, _e2, _f;
    let e = /* @__PURE__ */ new Date(), t = this.getSegment("MSH"), n = ((_a = t == null ? void 0 : t.getField(3)) == null ? void 0 : _a.toString()) ?? "", i = ((_b = t == null ? void 0 : t.getField(4)) == null ? void 0 : _b.toString()) ?? "", o = ((_c2 = t == null ? void 0 : t.getField(5)) == null ? void 0 : _c2.toString()) ?? "", s = ((_d = t == null ? void 0 : t.getField(6)) == null ? void 0 : _d.toString()) ?? "", a = ((_e2 = t == null ? void 0 : t.getField(10)) == null ? void 0 : _e2.toString()) ?? "", c = ((_f = t == null ? void 0 : t.getField(12)) == null ? void 0 : _f.toString()) ?? "2.5.1";
    return new r([new Ne(["MSH", this.context.getMsh2(), o, s, n, i, Ws(e), "", this.buildAckMessageType(t), e.getTime().toString(), "P", c], this.context), new Ne(["MSA", "AA", a, "OK"], this.context)]);
  }
  buildAckMessageType(e) {
    let t = e == null ? void 0 : e.getField(9), n = t == null ? void 0 : t.getComponent(2), i = t == null ? void 0 : t.getComponent(3), o = "ACK";
    return n && i ? o = `ACK^${n}^ACK` : n && (o = `ACK^${n}`), o;
  }
  static parse(e) {
    if (!e.startsWith("MSH")) {
      let n = new Error("Invalid HL7 message");
      throw n.type = "entity.parse.failed", n;
    }
    let t = new J("\r", e.charAt(3), e.charAt(4), e.charAt(5), e.charAt(6), e.charAt(7));
    return new r(e.split(/[\r\n]+/).map((n) => Ne.parse(n, t)), t);
  }
};
var Ne = class r2 {
  constructor(e, t = new J()) {
    this.context = t, pn(e) ? this.fields = e.map((n) => Se.parse(n, t)) : this.fields = e, this.name = this.fields[0].components[0][0];
  }
  get(e) {
    return this.fields[e];
  }
  getField(e) {
    if (this.name === "MSH") {
      if (e === 1)
        return new Se([[this.context.getMsh1()]], this.context);
      if (e === 2)
        return new Se([[this.context.getMsh2()]], this.context);
      if (e > 2)
        return this.fields[e - 1];
    }
    return this.fields[e];
  }
  getComponent(e, t, n, i = 0) {
    var _a;
    return ((_a = this.getField(e)) == null ? void 0 : _a.getComponent(t, n, i)) ?? "";
  }
  toString() {
    return this.fields.map((e) => e.toString()).join(this.context.fieldSeparator);
  }
  static parse(e, t = new J()) {
    return new r2(e.split(t.fieldSeparator).map((n) => Se.parse(n, t)), t);
  }
};
var Se = class r3 {
  constructor(e, t = new J()) {
    this.context = t, this.components = e;
  }
  get(e, t, n = 0) {
    return this.getComponent(e + 1, t, n);
  }
  getComponent(e, t, n = 0) {
    let i = this.components[n][e - 1] ?? "";
    return t !== void 0 && (i = i.split(this.context.subcomponentSeparator)[t] ?? ""), i;
  }
  toString() {
    return this.components.map((e) => e.join(this.context.componentSeparator)).join(this.context.repetitionSeparator);
  }
  static parse(e, t = new J()) {
    return new r3(e.split(t.repetitionSeparator).map((n) => n.split(t.componentSeparator)), t);
  }
};
function hd(r4, e) {
  if (!r4)
    return;
  let t = ae(r4.slice(0, 4), 0), n = ae(r4.slice(4, 6), 1) - 1, i = ae(r4.slice(6, 8), 1), o = ae(r4.slice(8, 10), 0), s = ae(r4.slice(10, 12), 0), a = ae(r4.slice(12, 14), 0), c = 0;
  r4.includes(".") && (c = ae(r4.slice(15, 19), 0));
  let u = new Date(Date.UTC(t, n, i, o, s, a, c)), p = Hs(r4, e == null ? void 0 : e.tzOffset);
  return p !== 0 && (u = new Date(u.getTime() - p)), u.toISOString();
}
function ae(r4, e) {
  let t = parseInt(r4, 10);
  return isNaN(t) ? e : t;
}
function Hs(r4, e) {
  let t = e, n = r4.indexOf("+");
  n !== -1 && (t = r4.slice(n));
  let i = r4.indexOf("-");
  if (i !== -1 && (t = r4.slice(i)), !t)
    return 0;
  let o = t.startsWith("-") ? -1 : 1;
  t = t.slice(1).replace(":", "");
  let s = parseInt(t.slice(0, 2), 10), a = parseInt(t.slice(2, 4), 10);
  return o * (s * 60 * 60 * 1e3 + a * 60 * 1e3);
}
function Ws(r4) {
  let e = r4 instanceof Date ? r4 : new Date(r4), n = e.toISOString().replace(/[-:T]/g, "").replace(/(\.\d+)?Z$/, ""), i = e.getUTCMilliseconds();
  return i > 0 && (n += "." + i.toString()), n;
}
var Rr = ((o) => (o[o.NONE = 0] = "NONE", o[o.ERROR = 1] = "ERROR", o[o.WARN = 2] = "WARN", o[o.INFO = 3] = "INFO", o[o.DEBUG = 4] = "DEBUG", o))(Rr || {});
var li = class {
  constructor(e, t = {}, n = 3) {
    this.write = e;
    this.metadata = t;
    this.level = n;
  }
  error(e, t) {
    this.log(1, e, t);
  }
  warn(e, t) {
    this.log(2, e, t);
  }
  info(e, t) {
    this.log(3, e, t);
  }
  debug(e, t) {
    this.log(4, e, t);
  }
  log(e, t, n) {
    var _a;
    e > this.level || (n instanceof Error && (n = { error: n.toString(), stack: (_a = n.stack) == null ? void 0 : _a.split(`
`) }), this.write(JSON.stringify({ level: Rr[e], timestamp: (/* @__PURE__ */ new Date()).toISOString(), msg: t, ...n, ...this.metadata })));
  }
};
function gd(r4) {
  let e = Rr[r4.toUpperCase()];
  if (e === void 0)
    throw new Error(`Invalid log level: ${r4}`);
  return e;
}
function Sd(r4) {
  if (!r4)
    throw new d(m("Resource type is null"));
  if (!Hr(r4))
    throw new d(m("Unknown resource type"));
}
function pi(r4, e, t) {
  r4 === null ? t.push(g(e, "Invalid null value")) : Array.isArray(r4) ? Ks(r4, e, t) : typeof r4 == "object" && zs(r4, e, t);
}
function Ks(r4, e, t) {
  for (let n = 0; n < r4.length; n++)
    r4[n] === void 0 ? t.push(g(`${e}[${n}]`, "Invalid undefined value")) : pi(r4[n], `${e}[${n}]`, t);
}
function zs(r4, e, t) {
  for (let [n, i] of Object.entries(r4))
    pi(i, `${e}${e ? "." : ""}${n}`, t);
}
function bd(r4) {
  let e = [];
  return new Promise((t, n) => {
    r4.on("data", (i) => e.push(Buffer.from(i))), r4.on("error", (i) => {
      r4.destroy(), n(i);
    }), r4.on("end", () => {
      t(Buffer.concat(e));
    }), r4.on("close", () => {
      r4.destroy();
    });
  });
}

export {
  Fe,
  H,
  _e,
  It,
  Pr,
  Ys,
  Zs,
  Xs,
  ea,
  ta,
  wr,
  na,
  ia,
  oa,
  Dr,
  sa,
  aa,
  ca,
  ua,
  la,
  pa,
  b,
  da,
  m,
  Mr,
  ce,
  Mt,
  fa,
  ma,
  ha,
  ya,
  ga,
  xa,
  d,
  Be,
  di,
  Nr,
  fi,
  ue,
  g,
  Fr,
  _r,
  Ta,
  hi,
  Ur,
  Lt,
  qt,
  jt,
  Gr,
  Qr,
  be,
  pe,
  Hr,
  Wr,
  Kr,
  Oa,
  Ht,
  Re,
  zr,
  $e,
  rc,
  zt,
  f,
  y,
  N,
  U,
  P,
  Pi,
  We,
  Jt,
  Yt,
  rn,
  Zt,
  Ai,
  Ke,
  nn,
  He,
  on,
  cc,
  A,
  sn,
  Z,
  X,
  Je,
  mc,
  ki,
  Oi,
  hc,
  yc,
  Ye,
  gc,
  xc,
  vc,
  Tc,
  Sc,
  Ec,
  $t,
  ln,
  S,
  G,
  Ge,
  Qe,
  ee,
  bc,
  O,
  pn,
  fn,
  mn,
  C,
  qe,
  tr,
  de,
  er,
  Rc,
  Cc,
  Pc,
  yn,
  wc,
  Ac,
  Ic,
  kc,
  $i,
  Gi,
  Oc,
  je,
  rr,
  Vc,
  Dc,
  fe,
  gn,
  Fc,
  Ze,
  _c,
  Uc,
  ir,
  Lc,
  Qi,
  nr,
  Bc,
  qc,
  jc,
  te,
  $c,
  Ji,
  Yi,
  Zi,
  l,
  Jc,
  or,
  Ut,
  to,
  Gt,
  Yc,
  Zc,
  Xc,
  eu,
  ro,
  ze,
  oo,
  _,
  Y,
  F,
  Tn,
  Xe,
  D,
  j,
  et,
  tt,
  re,
  R,
  I,
  rt,
  nt,
  it,
  W,
  ye,
  ot,
  st,
  at,
  ct,
  ne,
  ut,
  lt,
  pt,
  dt,
  Q,
  ie,
  K,
  h,
  Ae,
  sr,
  ge,
  $,
  En,
  bn,
  Cn,
  Uu,
  Qu,
  To,
  xe,
  Hu,
  Wu,
  Ku,
  Ro,
  zu,
  Ju,
  In,
  Bo,
  qo,
  jo,
  il,
  Go,
  ol,
  Qo,
  sl,
  Vn,
  Dn,
  pr,
  Mn,
  oe,
  Ho,
  Ko,
  ml,
  mt,
  M,
  ke,
  se,
  dr,
  Yo,
  fr,
  _n,
  Un,
  Zo,
  Xo,
  Ln,
  mr,
  yt,
  hr,
  ht,
  Bn,
  gt,
  qn,
  jn,
  k,
  Oe,
  yr,
  $n,
  gr,
  Ve,
  xt,
  ap,
  is,
  us,
  ls,
  ps,
  ds,
  vt,
  up,
  Tr,
  zn,
  Jn,
  Dp,
  Mp,
  Np,
  Fp,
  Ct,
  Zn,
  Wp,
  ed,
  Pt,
  wt,
  At,
  dd,
  J,
  ui,
  Ne,
  Se,
  hd,
  Ws,
  Rr,
  li,
  gd,
  Sd,
  pi,
  bd
};
//# sourceMappingURL=chunk-OUU4FBH3.js.map
